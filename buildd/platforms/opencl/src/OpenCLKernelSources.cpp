/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2010 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "OpenCLKernelSources.h"

using namespace OpenMM;
using namespace std;

const string OpenCLKernelSources::shakeHydrogens = "/**\n"
" * Enforce constraints on SHAKE clusters\n"
" */\n"
"\n"
"__kernel void applyShakeToHydrogens(int numClusters, float tol, __global const float4* restrict oldPos, __global float4* restrict posDelta, __global const int4* restrict clusterAtoms, __global const float4* restrict clusterParams) {\n"
"    int index = get_global_id(0);\n"
"    while (index < numClusters) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        float4 params = clusterParams[index];\n"
"        float4 pos = oldPos[atoms.x];\n"
"        float4 xpi = posDelta[atoms.x];\n"
"        float4 pos1 = oldPos[atoms.y];\n"
"        float4 xpj1 = posDelta[atoms.y];\n"
"        float4 pos2 = {0.0f, 0.0f, 0.0f, 0.0f};\n"
"        float4 xpj2 = {0.0f, 0.0f, 0.0f, 0.0f};\n"
"        float invMassCentral = params.x;\n"
"        float avgMass = params.y;\n"
"        float d2 = params.z;\n"
"        float invMassPeripheral = params.w;\n"
"        if (atoms.z != -1) {\n"
"            pos2 = oldPos[atoms.z];\n"
"            xpj2 = posDelta[atoms.z];\n"
"        }\n"
"        float4 pos3 = {0.0f, 0.0f, 0.0f, 0.0f};\n"
"        float4 xpj3 = {0.0f, 0.0f, 0.0f, 0.0f};\n"
"        if (atoms.w != -1) {\n"
"            pos3 = oldPos[atoms.w];\n"
"            xpj3 = posDelta[atoms.w];\n"
"        }\n"
"\n"
"        // Precompute quantities.\n"
"\n"
"        float4 rij1 = pos-pos1;\n"
"        float4 rij2 = pos-pos2;\n"
"        float4 rij3 = pos-pos3;\n"
"        float rij1sq = rij1.x*rij1.x + rij1.y*rij1.y + rij1.z*rij1.z;\n"
"        float rij2sq = rij2.x*rij2.x + rij2.y*rij2.y + rij2.z*rij2.z;\n"
"        float rij3sq = rij3.x*rij3.x + rij3.y*rij3.y + rij3.z*rij3.z;\n"
"        float ld1 = d2-rij1sq;\n"
"        float ld2 = d2-rij2sq;\n"
"        float ld3 = d2-rij3sq;\n"
"\n"
"        // Iterate until convergence.\n"
"\n"
"        bool converged = false;\n"
"        int iteration = 0;\n"
"        while (iteration < 15 && !converged) {\n"
"            converged = true;\n"
"#ifdef CONSTRAIN_VELOCITIES\n"
"            float4 rpij = xpi-xpj1;\n"
"            float rrpr = rpij.x*rij1.x + rpij.y*rij1.y + rpij.z*rij1.z;\n"
"            float delta = -2.0f*avgMass*rrpr/rij1sq;\n"
"            float4 dr = rij1*delta;\n"
"            xpi.xyz += dr.xyz*invMassCentral;\n"
"            xpj1.xyz -= dr.xyz*invMassPeripheral;\n"
"            if (fabs(delta) > tol)\n"
"                converged = false;\n"
"            if (atoms.z != -1) {\n"
"                rpij = xpi-xpj2;\n"
"                rrpr = rpij.x*rij2.x + rpij.y*rij2.y + rpij.z*rij2.z;\n"
"                delta = -2.0f*avgMass*rrpr/rij2sq;\n"
"                dr = rij2*delta;\n"
"                xpi.xyz += dr.xyz*invMassCentral;\n"
"                xpj2.xyz -= dr.xyz*invMassPeripheral;\n"
"                if (fabs(delta) > tol)\n"
"                    converged = false;\n"
"            }\n"
"            if (atoms.w != -1) {\n"
"                rpij = xpi-xpj3;\n"
"                rrpr = rpij.x*rij3.x + rpij.y*rij3.y + rpij.z*rij3.z;\n"
"                delta = -2.0f*avgMass*rrpr/rij3sq;\n"
"                dr = rij3*delta;\n"
"                xpi.xyz += dr.xyz*invMassCentral;\n"
"                xpj3.xyz -= dr.xyz*invMassPeripheral;\n"
"                if (fabs(delta) > tol)\n"
"                    converged = false;\n"
"            }\n"
"#else\n"
"            float4 rpij = xpi-xpj1;\n"
"            float rpsqij = rpij.x*rpij.x + rpij.y*rpij.y + rpij.z*rpij.z;\n"
"            float rrpr = rij1.x*rpij.x + rij1.y*rpij.y + rij1.z*rpij.z;\n"
"            float diff = fabs(ld1-2.0f*rrpr-rpsqij) / (d2*tol);\n"
"            if (diff >= 1.0f) {\n"
"                float acor  = (ld1-2.0f*rrpr-rpsqij)*avgMass / (rrpr+rij1sq);\n"
"                float4 dr = rij1*acor;\n"
"                xpi.xyz += dr.xyz*invMassCentral;\n"
"                xpj1.xyz -= dr.xyz*invMassPeripheral;\n"
"                converged = false;\n"
"            }\n"
"            if (atoms.z != -1) {\n"
"                rpij.xyz = xpi.xyz-xpj2.xyz;\n"
"                rpsqij = rpij.x*rpij.x + rpij.y*rpij.y + rpij.z*rpij.z;\n"
"                rrpr = rij2.x*rpij.x + rij2.y*rpij.y + rij2.z*rpij.z;\n"
"                diff = fabs(ld2-2.0f*rrpr-rpsqij) / (d2*tol);\n"
"                if (diff >= 1.0f) {\n"
"                    float acor  = (ld2 - 2.0f*rrpr - rpsqij)*avgMass / (rrpr + rij2sq);\n"
"                    float4 dr = rij2*acor;\n"
"                    xpi.xyz += dr.xyz*invMassCentral;\n"
"                    xpj2.xyz -= dr.xyz*invMassPeripheral;\n"
"                    converged = false;\n"
"                }\n"
"            }\n"
"            if (atoms.w != -1) {\n"
"                rpij.xyz = xpi.xyz-xpj3.xyz;\n"
"                rpsqij = rpij.x*rpij.x + rpij.y*rpij.y + rpij.z*rpij.z;\n"
"                rrpr = rij3.x*rpij.x + rij3.y*rpij.y + rij3.z*rpij.z;\n"
"                diff = fabs(ld3 - 2.0f*rrpr - rpsqij) / (d2*tol);\n"
"                if (diff >= 1.0f) {\n"
"                    float acor  = (ld3-2.0f*rrpr-rpsqij)*avgMass / (rrpr+rij3sq);\n"
"                    float4 dr = rij3*acor;\n"
"                    xpi.xyz += dr.xyz*invMassCentral;\n"
"                    xpj3.xyz -= dr.xyz*invMassPeripheral;\n"
"                    converged = false;\n"
"                }\n"
"            }\n"
"#endif\n"
"            iteration++;\n"
"        }\n"
"\n"
"        // Record the new positions.\n"
"\n"
"        posDelta[atoms.x] = xpi;\n"
"        posDelta[atoms.y] = xpj1;\n"
"        if (atoms.z != -1)\n"
"            posDelta[atoms.z] = xpj2;\n"
"        if (atoms.w != -1)\n"
"            posDelta[atoms.w] = xpj3;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::rbTorsionForce = "const float PI = 3.14159265358979323846f;\n"
"float8 torsionParams = PARAMS[index];\n"
"float4 v0 = (float4) (pos1.xyz-pos2.xyz, 0.0f);\n"
"float4 v1 = (float4) (pos3.xyz-pos2.xyz, 0.0f);\n"
"float4 v2 = (float4) (pos3.xyz-pos4.xyz, 0.0f);\n"
"float4 cp0 = cross(v0, v1);\n"
"float4 cp1 = cross(v1, v2);\n"
"float cosangle = dot(normalize(cp0), normalize(cp1));\n"
"float dihedralAngle;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    float4 cross_prod = cross(cp0, cp1);\n"
"    float scale = dot(cp0, cp0)*dot(cp1, cp1);\n"
"    dihedralAngle = asin(sqrt(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        dihedralAngle = PI-dihedralAngle;\n"
"}\n"
"else\n"
"   dihedralAngle = acos(cosangle);\n"
"dihedralAngle = (dot(v0, cp1) >= 0 ? dihedralAngle : -dihedralAngle);\n"
"if (dihedralAngle < 0.0f)\n"
"    dihedralAngle += PI;\n"
"else\n"
"    dihedralAngle -= PI;\n"
"cosangle = -cosangle;\n"
"float cosFactor = cosangle;\n"
"float dEdAngle = -torsionParams.s1;\n"
"float rbEnergy = torsionParams.s0;\n"
"rbEnergy += torsionParams.s1*cosFactor;\n"
"dEdAngle -= 2.0f*torsionParams.s2*cosFactor;\n"
"cosFactor *= cosangle;\n"
"dEdAngle -= 3.0f*torsionParams.s3*cosFactor;\n"
"rbEnergy += torsionParams.s2*cosFactor;\n"
"cosFactor *= cosangle;\n"
"dEdAngle -= 4.0f*torsionParams.s4*cosFactor;\n"
"rbEnergy += torsionParams.s3*cosFactor;\n"
"cosFactor *= cosangle;\n"
"dEdAngle -= 5.0f*torsionParams.s5*cosFactor;\n"
"rbEnergy += torsionParams.s4*cosFactor;\n"
"rbEnergy += torsionParams.s5*cosFactor*cosangle;\n"
"energy += rbEnergy;\n"
"dEdAngle *= sin(dihedralAngle);\n"
"float normCross1 = dot(cp0, cp0);\n"
"float normSqrBC = dot(v1, v1);\n"
"float normBC = sqrt(normSqrBC);\n"
"float normCross2 = dot(cp1, cp1);\n"
"float dp = 1.0f/normSqrBC;\n"
"float4 ff = (float4) ((-dEdAngle*normBC)/normCross1, dot(v0, v1)*dp, dot(v2, v1)*dp, (dEdAngle*normBC)/normCross2);\n"
"float4 force1 = ff.x*cp0;\n"
"float4 force4 = ff.w*cp1;\n"
"float4 s = ff.y*force1 - ff.z*force4;\n"
"float4 force2 = s-force1;\n"
"float4 force3 = -s-force4;\n"
"";
const string OpenCLKernelSources::harmonicBondForce = "float4 delta = pos2-pos1;\n"
"float2 bondParams = PARAMS[index];\n"
"float r = SQRT(delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);\n"
"float deltaIdeal = r-bondParams.x;\n"
"energy += 0.5f * bondParams.y*deltaIdeal*deltaIdeal;\n"
"float dEdR = bondParams.y * deltaIdeal;\n"
"dEdR = (r > 0.0f) ? (dEdR / r) : 0.0f;\n"
"delta.xyz *= dEdR;\n"
"float4 force1 = delta;\n"
"float4 force2 = -delta;";
const string OpenCLKernelSources::verlet = "#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"/**\n"
" * Perform the first step of verlet integration.\n"
" */\n"
"\n"
"__kernel void integrateVerletPart1(int numAtoms, __global const float2* restrict dt, __global const float4* restrict posq, __global float4* restrict velm, __global const float4* restrict force, __global float4* restrict posDelta) {\n"
"    float2 stepSize = dt[0];\n"
"    float dtPos = stepSize.y;\n"
"    float dtVel = 0.5f*(stepSize.x+stepSize.y);\n"
"    int index = get_global_id(0);\n"
"    while (index < numAtoms) {\n"
"        float4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            float4 pos = posq[index];\n"
"            velocity.xyz += force[index].xyz*dtVel*velocity.w;\n"
"            pos.xyz = velocity.xyz*dtPos;\n"
"            posDelta[index] = pos;\n"
"            velm[index] = velocity;\n"
"        }\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of verlet integration.\n"
" */\n"
"\n"
"__kernel void integrateVerletPart2(int numAtoms, __global float2* restrict dt, __global float4* restrict posq, __global float4* restrict velm, __global const float4* restrict posDelta) {\n"
"    float2 stepSize = dt[0];\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"    double oneOverDt = 1.0/stepSize.y;\n"
"#else\n"
"    float oneOverDt = 1.0f/stepSize.y;\n"
"#endif\n"
"    if (get_global_id(0) == 0)\n"
"        dt[0].x = stepSize.y;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    int index = get_global_id(0);\n"
"    while (index < numAtoms) {\n"
"        float4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            float4 pos = posq[index];\n"
"            float4 delta = posDelta[index];\n"
"            pos.xyz += delta.xyz;\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"            velocity.xyz = convert_float4(convert_double4(delta)*oneOverDt).xyz;\n"
"#else\n"
"            velocity.xyz = delta.xyz*oneOverDt;\n"
"#endif\n"
"            posq[index] = pos;\n"
"            velm[index] = velocity;\n"
"        }\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Select the step size to use for the next step.\n"
" */\n"
"\n"
"__kernel void selectVerletStepSize(int numAtoms, float maxStepSize, float errorTol, __global float2* restrict dt, __global const float4* restrict velm, __global const float4* restrict force, __local float* restrict error) {\n"
"    // Calculate the error.\n"
"\n"
"    float err = 0.0f;\n"
"    int index = get_local_id(0);\n"
"    while (index < numAtoms) {\n"
"        float4 f = force[index];\n"
"        float invMass = velm[index].w;\n"
"        err += (f.x*f.x + f.y*f.y + f.z*f.z)*invMass;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    error[get_local_id(0)] = err;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Sum the errors from all threads.\n"
"\n"
"    for (unsigned int offset = 1; offset < get_local_size(0); offset *= 2) {\n"
"        if (get_local_id(0)+offset < get_local_size(0) && (get_local_id(0)&(2*offset-1)) == 0)\n"
"            error[get_local_id(0)] += error[get_local_id(0)+offset];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    if (get_local_id(0) == 0) {\n"
"        float totalError = sqrt(error[0]/(numAtoms*3));\n"
"        float newStepSize = sqrt(errorTol/totalError);\n"
"        float oldStepSize = dt[0].y;\n"
"        if (oldStepSize > 0.0f)\n"
"            newStepSize = min(newStepSize, oldStepSize*2.0f); // For safety, limit how quickly dt can increase.\n"
"        if (newStepSize > oldStepSize && newStepSize < 1.1f*oldStepSize)\n"
"            newStepSize = oldStepSize; // Keeping dt constant between steps improves the behavior of the integrator.\n"
"        if (newStepSize > maxStepSize)\n"
"            newStepSize = maxStepSize;\n"
"        dt[0].y = newStepSize;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::random = "/**\n"
" * Generate random numbers\n"
" */\n"
"\n"
"__kernel void generateRandomNumbers(int numValues, __global float4* restrict random, __global uint4* restrict seed) {\n"
"    int index = get_global_id(0);\n"
"    uint4 state = seed[index];\n"
"    unsigned int carry = 0;\n"
"    while (index < numValues) {\n"
"        float4 value;\n"
"\n"
"        // Generate first value.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        unsigned int k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        unsigned int m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x1 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        x1 = sqrt(-2.0f * log(x1));\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x2 = (float)(state.x + state.y + state.w) / (float)0xffffffff;\n"
"        value.x = x1 * cos(2.0f * 3.14159265f * x2);\n"
"\n"
"        // Generate second value.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x3 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        x3 = sqrt(-2.0f * log(x3));\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x4 = (float)(state.x + state.y + state.w) / (float)0xffffffff;\n"
"        value.y = x3 * cos(2.0f * 3.14159265f * x4);\n"
"\n"
"        // Generate third value.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x5 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        x5 = sqrt(-2.0f * log(x5));\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x6 = (float)(state.x + state.y + state.w) / (float)0xffffffff;\n"
"        value.z = x5 * cos(2.0f * 3.14159265f * x6);\n"
"\n"
"        // Generate fourth value.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x7 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        x7 = sqrt(-2.0f * log(x7));\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x8 = (float)(state.x + state.y + state.w) / (float)0xffffffff;\n"
"        value.w = x7 * cos(2.0f * 3.14159265f * x8);\n"
"\n"
"        // Record the values.\n"
"\n"
"        random[index] = value;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    seed[get_global_id(0)] = state;\n"
"}\n"
"";
const string OpenCLKernelSources::customHbondForce = "/**\n"
" * Compute the difference between two vectors, setting the fourth component to the squared magnitude.\n"
" */\n"
"float4 delta(float4 vec1, float4 vec2) {\n"
"    float4 result = (float4) (vec1.x-vec2.x, vec1.y-vec2.y, vec1.z-vec2.z, 0.0f);\n"
"    result.w = result.x*result.x + result.y*result.y + result.z*result.z;\n"
"    return result;\n"
"}\n"
"\n"
"/**\n"
" * Compute the difference between two vectors, taking periodic boundary conditions into account\n"
" * and setting the fourth component to the squared magnitude.\n"
" */\n"
"float4 deltaPeriodic(float4 vec1, float4 vec2, float4 periodicBoxSize, float4 invPeriodicBoxSize) {\n"
"    float4 result = (float4) (vec1.x-vec2.x, vec1.y-vec2.y, vec1.z-vec2.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"    result.x -= floor(result.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"    result.y -= floor(result.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"    result.z -= floor(result.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"    result.w = result.x*result.x + result.y*result.y + result.z*result.z;\n"
"    return result;\n"
"}\n"
"\n"
"/**\n"
" * Compute the angle between two vectors.  The w component of each vector should contain the squared magnitude.\n"
" */\n"
"float computeAngle(float4 vec1, float4 vec2) {\n"
"    float dotProduct = vec1.x*vec2.x + vec1.y*vec2.y + vec1.z*vec2.z;\n"
"    float cosine = dotProduct*RSQRT(vec1.w*vec2.w);\n"
"    float angle;\n"
"    if (cosine > 0.99f || cosine < -0.99f) {\n"
"        // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"        float4 crossProduct = cross(vec1, vec2);\n"
"        float scale = vec1.w*vec2.w;\n"
"        angle = asin(SQRT(dot(crossProduct, crossProduct)/scale));\n"
"        if (cosine < 0.0f)\n"
"            angle = M_PI-angle;\n"
"    }\n"
"    else\n"
"       angle = acos(cosine);\n"
"    return angle;\n"
"}\n"
"\n"
"/**\n"
" * Compute the cross product of two vectors, setting the fourth component to the squared magnitude.\n"
" */\n"
"float4 computeCross(float4 vec1, float4 vec2) {\n"
"    float4 result = cross(vec1, vec2);\n"
"    result.w = result.x*result.x + result.y*result.y + result.z*result.z;\n"
"    return result;\n"
"}\n"
"\n"
"/**\n"
" * Compute forces on donors.\n"
" */\n"
"__kernel void computeDonorForces(__global float4* restrict forceBuffers, __global float* restrict energyBuffer, __global const float4* restrict posq, __global const int4* restrict exclusions,\n"
"        __global const int4* restrict donorAtoms, __global const int4* restrict acceptorAtoms, __global const int4* restrict donorBufferIndices, __local float4* posBuffer, float4 periodicBoxSize, float4 invPeriodicBoxSize\n"
"        PARAMETER_ARGUMENTS) {\n"
"    float energy = 0.0f;\n"
"    float4 f1 = (float4) 0;\n"
"    float4 f2 = (float4) 0;\n"
"    float4 f3 = (float4) 0;\n"
"    for (int donorStart = 0; donorStart < NUM_DONORS; donorStart += get_global_size(0)) {\n"
"        // Load information about the donor this thread will compute forces on.\n"
"\n"
"        int donorIndex = donorStart+get_global_id(0);\n"
"        int4 atoms, exclusionIndices;\n"
"        float4 d1, d2, d3;\n"
"        if (donorIndex < NUM_DONORS) {\n"
"            atoms = donorAtoms[donorIndex];\n"
"            d1 = (atoms.x > -1 ? posq[atoms.x] : (float4) 0);\n"
"            d2 = (atoms.y > -1 ? posq[atoms.y] : (float4) 0);\n"
"            d3 = (atoms.z > -1 ? posq[atoms.z] : (float4) 0);\n"
"#ifdef USE_EXCLUSIONS\n"
"            exclusionIndices = exclusions[donorIndex];\n"
"#endif\n"
"        }\n"
"        else\n"
"            atoms = (int4) (-1, -1, -1, -1);\n"
"        for (int acceptorStart = 0; acceptorStart < NUM_ACCEPTORS; acceptorStart += get_local_size(0)) {\n"
"            // Load the next block of acceptors into local memory.\n"
"\n"
"            int blockSize = min((int) get_local_size(0), NUM_ACCEPTORS-acceptorStart);\n"
"            if (get_local_id(0) < blockSize) {\n"
"                int4 atoms2 = acceptorAtoms[acceptorStart+get_local_id(0)];\n"
"                posBuffer[3*get_local_id(0)] = (atoms2.x > -1 ? posq[atoms2.x] : (float4) 0);\n"
"                posBuffer[3*get_local_id(0)+1] = (atoms2.y > -1 ? posq[atoms2.y] : (float4) 0);\n"
"                posBuffer[3*get_local_id(0)+2] = (atoms2.z > -1 ? posq[atoms2.z] : (float4) 0);\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (donorIndex < NUM_DONORS) {\n"
"                for (int index = 0; index < blockSize; index++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    int acceptorIndex = acceptorStart+index;\n"
"                    if (acceptorIndex == exclusionIndices.x || acceptorIndex == exclusionIndices.y || acceptorIndex == exclusionIndices.z || acceptorIndex == exclusionIndices.w)\n"
"                        continue;\n"
"#endif\n"
"                    // Compute the interaction between a donor and an acceptor.\n"
"\n"
"                    float4 a1 = posBuffer[3*index];\n"
"                    float4 a2 = posBuffer[3*index+1];\n"
"                    float4 a3 = posBuffer[3*index+2];\n"
"                    float4 deltaD1A1 = deltaPeriodic(d1, a1, periodicBoxSize, invPeriodicBoxSize);\n"
"#ifdef USE_CUTOFF\n"
"                    if (deltaD1A1.w < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        COMPUTE_DONOR_FORCE\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        // Write results\n"
"\n"
"        if (donorIndex < NUM_DONORS) {\n"
"            int4 bufferIndices = donorBufferIndices[donorIndex];\n"
"            if (atoms.x > -1) {\n"
"                unsigned int offset = atoms.x+bufferIndices.x*PADDED_NUM_ATOMS;\n"
"                float4 force = forceBuffers[offset];\n"
"                force.xyz += f1.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.y > -1) {\n"
"                unsigned int offset = atoms.y+bufferIndices.y*PADDED_NUM_ATOMS;\n"
"                float4 force = forceBuffers[offset];\n"
"                force.xyz += f2.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.z > -1) {\n"
"                unsigned int offset = atoms.z+bufferIndices.z*PADDED_NUM_ATOMS;\n"
"                float4 force = forceBuffers[offset];\n"
"                force.xyz += f3.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"        }\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"/**\n"
" * Compute forces on acceptors.\n"
" */\n"
"__kernel void computeAcceptorForces(__global float4* restrict forceBuffers, __global float* restrict energyBuffer, __global const float4* restrict posq, __global const int4* restrict exclusions,\n"
"        __global const int4* restrict donorAtoms, __global const int4* restrict acceptorAtoms, __global const int4* restrict acceptorBufferIndices, __local float4* restrict posBuffer, float4 periodicBoxSize, float4 invPeriodicBoxSize\n"
"        PARAMETER_ARGUMENTS) {\n"
"    float4 f1 = (float4) 0;\n"
"    float4 f2 = (float4) 0;\n"
"    float4 f3 = (float4) 0;\n"
"    for (int acceptorStart = 0; acceptorStart < NUM_ACCEPTORS; acceptorStart += get_global_size(0)) {\n"
"        // Load information about the acceptor this thread will compute forces on.\n"
"\n"
"        int acceptorIndex = acceptorStart+get_global_id(0);\n"
"        int4 atoms, exclusionIndices;\n"
"        float4 a1, a2, a3;\n"
"        if (acceptorIndex < NUM_ACCEPTORS) {\n"
"            atoms = acceptorAtoms[acceptorIndex];\n"
"            a1 = (atoms.x > -1 ? posq[atoms.x] : (float4) 0);\n"
"            a2 = (atoms.y > -1 ? posq[atoms.y] : (float4) 0);\n"
"            a3 = (atoms.z > -1 ? posq[atoms.z] : (float4) 0);\n"
"#ifdef USE_EXCLUSIONS\n"
"            exclusionIndices = exclusions[acceptorIndex];\n"
"#endif\n"
"        }\n"
"        else\n"
"            atoms = (int4) (-1, -1, -1, -1);\n"
"        for (int donorStart = 0; donorStart < NUM_DONORS; donorStart += get_local_size(0)) {\n"
"            // Load the next block of donors into local memory.\n"
"\n"
"            int blockSize = min((int) get_local_size(0), NUM_DONORS-donorStart);\n"
"            if (get_local_id(0) < blockSize) {\n"
"                int4 atoms2 = donorAtoms[donorStart+get_local_id(0)];\n"
"                posBuffer[3*get_local_id(0)] = (atoms2.x > -1 ? posq[atoms2.x] : (float4) 0);\n"
"                posBuffer[3*get_local_id(0)+1] = (atoms2.y > -1 ? posq[atoms2.y] : (float4) 0);\n"
"                posBuffer[3*get_local_id(0)+2] = (atoms2.z > -1 ? posq[atoms2.z] : (float4) 0);\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (acceptorIndex < NUM_ACCEPTORS) {\n"
"                for (int index = 0; index < blockSize; index++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    int donorIndex = donorStart+index;\n"
"                    if (donorIndex == exclusionIndices.x || donorIndex == exclusionIndices.y || donorIndex == exclusionIndices.z || donorIndex == exclusionIndices.w)\n"
"                        continue;\n"
"#endif\n"
"                    // Compute the interaction between a donor and an acceptor.\n"
"\n"
"                    float4 d1 = posBuffer[3*index];\n"
"                    float4 d2 = posBuffer[3*index+1];\n"
"                    float4 d3 = posBuffer[3*index+2];\n"
"                    float4 deltaD1A1 = deltaPeriodic(d1, a1, periodicBoxSize, invPeriodicBoxSize);\n"
"#ifdef USE_CUTOFF\n"
"                    if (deltaD1A1.w < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        COMPUTE_ACCEPTOR_FORCE\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        // Write results\n"
"\n"
"        if (acceptorIndex < NUM_ACCEPTORS) {\n"
"            int4 bufferIndices = acceptorBufferIndices[acceptorIndex];\n"
"            if (atoms.x > -1) {\n"
"                unsigned int offset = atoms.x+bufferIndices.x*PADDED_NUM_ATOMS;\n"
"                float4 force = forceBuffers[offset];\n"
"                force.xyz += f1.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.y > -1) {\n"
"                unsigned int offset = atoms.y+bufferIndices.y*PADDED_NUM_ATOMS;\n"
"                float4 force = forceBuffers[offset];\n"
"                force.xyz += f2.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"            if (atoms.z > -1) {\n"
"                unsigned int offset = atoms.z+bufferIndices.z*PADDED_NUM_ATOMS;\n"
"                float4 force = forceBuffers[offset];\n"
"                force.xyz += f3.xyz;\n"
"                forceBuffers[offset] = force;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customGBValueN2_cpu = "#define TILE_SIZE 32\n"
"\n"
"/**\n"
" * Compute a value based on pair interactions.\n"
" */\n"
"\n"
"__kernel void computeN2Value(__global const float4* restrict posq, __local float4* restrict local_posq, __global const unsigned int* restrict exclusions,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global float* restrict global_value, __local float* restrict local_value,\n"
"        __local float* restrict tempBuffer,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"\n"
"        // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int exclusionStart = exclusionRowIndices[x];\n"
"        unsigned int exclusionEnd = exclusionRowIndices[x+1];\n"
"        int exclusionIndex = -1;\n"
"        for (int i = exclusionStart; i < exclusionEnd; i++)\n"
"            if (exclusionIndices[i] == y) {\n"
"                exclusionIndex = i*TILE_SIZE;\n"
"                break;\n"
"            }\n"
"        bool hasExclusions = (exclusionIndex > -1);\n"
"#else\n"
"        bool hasExclusions = false;\n"
"#endif\n"
"\n"
"        // Load the data for this tile if we don't already have it cached.\n"
"\n"
"        if (lasty != y) {\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"                local_posq[localAtomIndex] = posq[j];\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[exclusionIndex+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float value = 0.0f;\n"
"                float4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    float4 posq2 = local_posq[j];\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    float invR = RSQRT(r2);\n"
"                    float r = RECIP(invR);\n"
"                    unsigned int atom2 = j;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    float tempValue1 = 0.0f;\n"
"                    float tempValue2 = 0.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    if (!isExcluded && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"                        COMPUTE_VALUE\n"
"                    }\n"
"                    value += tempValue1;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results\n"
"\n"
"                unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_value[offset] += value;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++)\n"
"                local_value[tgx] = 0.0f;\n"
"#if defined(USE_CUTOFF) && defined(USE_EXCLUSIONS)\n"
"            unsigned int flags1 = (numTiles <= maxTiles ? interactionFlags[2*pos] : 0xFFFFFFFF);\n"
"            unsigned int flags2 = (numTiles <= maxTiles ? interactionFlags[2*pos+1] : 0xFFFFFFFF);\n"
"            if (!hasExclusions && (flags1 != 0xFFFFFFFF || flags2 != 0xFFFFFFFF)) {\n"
"                // Compute only a subset of the interactions in this tile.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    if ((flags2&(1<<tgx)) != 0) {\n"
"                        unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                        float value = 0.0f;\n"
"                        float4 posq1 = posq[atom1];\n"
"                        LOAD_ATOM1_PARAMETERS\n"
"                        for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags&(1<<j)) != 0) {\n"
"                                float4 posq2 = local_posq[j];\n"
"                                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                                float r2 = dot(delta.xyz, delta.xyz);\n"
"                                float tempValue1 = 0.0f;\n"
"                                float tempValue2 = 0.0f;\n"
"                                if (r2 < CUTOFF_SQUARED) {\n"
"                                    float invR = RSQRT(r2);\n"
"                                    float r = RECIP(invR);\n"
"                                    unsigned int atom2 = j;\n"
"                                    LOAD_ATOM2_PARAMETERS\n"
"                                    atom2 = y*TILE_SIZE+j;\n"
"                                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                                        COMPUTE_VALUE\n"
"                                    }\n"
"                                    value += tempValue1;\n"
"                                    local_value[j] += tempValue2;\n"
"                                }\n"
"                            }\n"
"                        }\n"
"\n"
"                        // Write results for atom1.\n"
"\n"
"                        unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        global_value[offset] += value;\n"
"                    }\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // Compute the full set of interactions in this tile.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    float value = 0.0f;\n"
"                    float4 posq1 = posq[atom1];\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"                    unsigned int excl = (hasExclusions ? exclusions[exclusionIndex+tgx] : 0xFFFFFFFF);\n"
"#endif\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        float4 posq2 = local_posq[j];\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                        float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"                        float tempValue1 = 0.0f;\n"
"                        float tempValue2 = 0.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                        if (!isExcluded && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                            COMPUTE_VALUE\n"
"                        }\n"
"                        value += tempValue1;\n"
"                        local_value[j] += tempValue2;\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        excl >>= 1;\n"
"#endif\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"                    unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    global_value[offset] += value;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int offset = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_value[offset] += local_value[tgx];\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customIntegrator = "__kernel void computeSum(__global const float* restrict sumBuffer, __global float* result, unsigned int outputIndex, int bufferSize) {\n"
"    __local float tempBuffer[WORK_GROUP_SIZE];\n"
"    const unsigned int thread = get_local_id(0);\n"
"    float sum = 0.0f;\n"
"    for (unsigned int index = thread; index < bufferSize; index += get_local_size(0))\n"
"        sum += sumBuffer[index];\n"
"    tempBuffer[thread] = sum;\n"
"    for (int i = 1; i < WORK_GROUP_SIZE; i *= 2) {\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (thread%(i*2) == 0 && thread+i < WORK_GROUP_SIZE)\n"
"            tempBuffer[thread] += tempBuffer[thread+i];\n"
"    }\n"
"    if (thread == 0)\n"
"        result[outputIndex] = tempBuffer[0];\n"
"}\n"
"\n"
"__kernel void applyPositionDeltas(__global float4* restrict posq, __global float4* restrict posDelta) {\n"
"    for (unsigned int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        float4 position = posq[index];\n"
"        position.xyz += posDelta[index].xyz;\n"
"        posq[index] = position;\n"
"        posDelta[index] = (float4) 0.0f;\n"
"    }\n"
"}\n"
"\n"
"__kernel void generateRandomNumbers(__global float4* restrict random, __global uint4* restrict seed) {\n"
"    uint4 state = seed[get_global_id(0)];\n"
"    unsigned int carry = 0;\n"
"    for (int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        // Generate three uniform random numbers.\n"
"\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        unsigned int k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        unsigned int m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x1 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x2 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"        state.x = state.x * 69069 + 1;\n"
"        state.y ^= state.y << 13;\n"
"        state.y ^= state.y >> 17;\n"
"        state.y ^= state.y << 5;\n"
"        k = (state.z >> 2) + (state.w >> 3) + (carry >> 2);\n"
"        m = state.w + state.w + state.z + carry;\n"
"        state.z = state.w;\n"
"        state.w = m;\n"
"        carry = k >> 30;\n"
"        float x3 = (float)max(state.x + state.y + state.w, 0x00000001u) / (float)0xffffffff;\n"
"\n"
"        // Record the values.\n"
"\n"
"        random[index] = (float4) (x1, x2, x3, 0.0f);\n"
"    }\n"
"    seed[get_global_id(0)] = state;\n"
"}\n"
"";
const string OpenCLKernelSources::berendsen = "\n"
"/**\n"
" * @todo: replace the preprocessor with dynamic values\n"
" * using compiler prefix inside opencl\n"
" */\n"
"\n"
"\n"
"__kernel void binMomentum(\n"
"                          __global const float4* restrict velm,\n"
"                          __global const float4* restrict posq,\n"
"                          __global const float4* restrict startPoint,\n"
"                          __global const float4* restrict unitVector,\n"
"                          __global float4* restrict glMomentum,\n"
"                          __global float* restrict testArray,\n"
"                          int nBins\n"
"                          )\n"
"{\n"
"    unsigned int idx = get_global_id(0);\n"
"    int nbins = (int) NBINS;\n"
"    if(idx<NUM_ATOMS)\n"
"    {\n"
"        float4 pos = posq[idx];\n"
"        float4 velocity = velm[idx];\n"
"        float4 rSI = pos - startPoint[0];\n"
"        float rD = ((rSI.x*unitVector[0].x)+(rSI.y*unitVector[0].y)+(rSI.z*unitVector[0].z));\n"
"        int bn = (int) rD/unitVector[0].w;\n"
"        unsigned int s = bn == nBins;\n"
"        bn -= s;\n"
"        glMomentum[idx*nbins+bn] += (float4) (velocity.x * (1.0f/velocity.w),\n"
"						velocity.y * (1.0f/velocity.w),\n"
"						velocity.z * (1.0f/velocity.w),\n"
"						velocity.w);\n"
"    }\n"
"    \n"
"}\n"
"\n"
"__kernel void calculatebinke(__global const float4* restrict velm,\n"
"                             __global const float4* restrict posq,\n"
"                             __global const float4* restrict startPoint,\n"
"                             __global const float4* restrict unitVector,\n"
"                             __global const float4* restrict newVelocity,\n"
"                             __global float4* restrict glKe\n"
"                             )\n"
"{\n"
"    unsigned int idx = get_global_id(0);\n"
"    int nbins = (int) NBINS;\n"
"    if(idx < NUM_ATOMS)\n"
"    {\n"
"        float4 pos = posq[idx];\n"
"        float4 velocity = velm[idx];\n"
"	float4 rSI = pos - startPoint[0];\n"
"        float rD = ((rSI.x*unitVector[0].x)+(rSI.y*unitVector[0].y)+(rSI.z*unitVector[0].z));\n"
"        int bn = (int) rD/unitVector[0].w;\n"
"        unsigned int s = bn == nbins;\n"
"        bn -= s;\n"
"        float4 diffvel = velocity - newVelocity[bn];\n"
"        rD = ((diffvel.x*diffvel.x)+(diffvel.y*diffvel.y)+(diffvel.z*diffvel.z));\n"
"        glKe[idx*nbins+bn] += (float4) (0.5*(1.0f/velocity.w)*rD,3.0f,1.0f,0.0f);\n"
"    }\n"
"}\n"
"\n"
"//update velocities in bins\n"
"__kernel void updateVelocitiesInBins(__global const float4* restrict posq,\n"
"                                     __global const float4* restrict startPoint,\n"
"                                     __global const float4* restrict unitVector,\n"
"                                     __global const float* restrict binChi,\n"
"                                     __global float4* restrict velm\n"
"                                     )\n"
"{\n"
"    unsigned int idx = get_global_id(0);\n"
"    int nbins = (int) NBINS;\n"
"    if(idx<NUM_ATOMS)\n"
"    {\n"
"        float4 pos = posq[idx];\n"
"        float4 velocity = velm[idx];\n"
"	float4 rSI = pos - startPoint[0];\n"
"        float rD = ((rSI.x*unitVector[0].x)+(rSI.y*unitVector[0].y)+(rSI.z*unitVector[0].z));\n"
"        int bn = (int) rD/unitVector[0].w;\n"
"        unsigned int s = bn == nbins;\n"
"        bn -= s;\n"
"        if(velocity.x!=0.0)\n"
"			velocity.x *= binChi[bn];\n"
"		if(velocity.y!=0.0)\n"
"			velocity.y *= binChi[bn];\n"
"		if(velocity.z!=0.0)\n"
"			velocity.z *= binChi[bn];\n"
"		velm[idx] = velocity;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * berendsen thermostat kernel\n"
" * this file implements the OpenCL-gpu version\n"
" * of the berendsen thermostat\n"
" */\n"
"\n"
"__kernel void berendsen1(int numAtoms,\n"
"			__global float4* restrict velm,\n"
"			__global float4* restrict totalMomM,\n"
"			__local volatile float4* restrict localMomm\n"
"			)\n"
"{\n"
"	unsigned int idx = get_global_id(0);\n"
"	unsigned int tid = get_local_id(0);\n"
"	float4 tempvel = (float4) 0.0f;\n"
"	//copy the velocity from its global location to shared/local memory\n"
"	while(idx<NUM_ATOMS)\n"
"	{\n"
"		float4 velocity = velm[idx];\n"
"		if(velocity.w != 0.0){\n"
"			tempvel.xyz += velocity.w*velocity.xyz;\n"
"			tempvel.w += velocity.w;\n"
"		}\n"
"		idx += get_global_size(0);\n"
"	}\n"
"	/* copy the total per thread to shared/local\n"
"       	 * array created for total momentum and mass\n"
" 	 * it is a float 4 array storing total momentum in xyz \n"
"	 * components and total mass in w component.\n"
"	 */\n"
"\n"
"	localMomm[tid] = tempvel;\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if(tid<32)\n"
"		localMomm[tid] += localMomm[tid+32];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<16)\n"
"		localMomm[tid] += localMomm[tid+16];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<8)\n"
"		localMomm[tid] += localMomm[tid+8];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<4)\n"
"		localMomm[tid] += localMomm[tid+4];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<2)\n"
"		localMomm[tid] += localMomm[tid+2];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if(tid==0)\n"
"		totalMomM[get_group_id(0)] = localMomm[tid] + localMomm[tid+1];\n"
"\n"
"}\n"
"\n"
"__kernel void calculateKEDOF(__global float4* restrict velm,\n"
"				__global float4* restrict newVelocity,\n"
"				__global float2* restrict KeDof,\n"
"				__local volatile float2* restrict localKeDof\n"
"				)\n"
"{\n"
"	unsigned int idx = get_global_id(0);\n"
"	float2 tempkedof = (float2) 0.0f;\n"
"	while(idx<NUM_ATOMS)\n"
"	{\n"
"		float4 velocity = velm[idx];\n"
"		float4 diffvel = velocity - newVelocity[0];\n"
"		float sqr = ((diffvel.x*diffvel.x)+(diffvel.y*diffvel.y)+(diffvel.z*diffvel.z));\n"
"		tempkedof.x += (0.5*sqr)/velocity.w;\n"
"		tempkedof.y += 3.0;\n"
"		idx += get_global_size(0);\n"
"	}\n"
"	unsigned int tid = get_local_id(0);\n"
"	localKeDof[tid] = tempkedof;\n"
"\n"
"	if(tid<32)\n"
"		localKeDof[tid] += localKeDof[tid+32];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<16)\n"
"		localKeDof[tid] += localKeDof[tid+16];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<8)\n"
"		localKeDof[tid] += localKeDof[tid+8];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<4)\n"
"		localKeDof[tid] += localKeDof[tid+4];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<2)\n"
"		localKeDof[tid] += localKeDof[tid+2];\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if(tid==0)\n"
"		KeDof[get_group_id(0)] = localKeDof[tid] + localKeDof[tid+1];\n"
"}\n"
"\n"
"\n"
"__kernel void updateVelocities(__global float4* restrict velm,\n"
"				__global float* restrict chi\n"
"				)\n"
"{\n"
"	unsigned int idx = get_global_id(0);\n"
"	float tempchi = chi[0];\n"
"	while(idx<NUM_ATOMS)\n"
"	{\n"
"		float4 velocity = velm[idx];\n"
"		if(velocity.x!=0.0)\n"
"			velocity.x *= tempchi;\n"
"		if(velocity.y!=0.0)\n"
"			velocity.y *= tempchi;\n"
"		if(velocity.z!=0.0)\n"
"			velocity.z *= tempchi;\n"
"		velm[idx] = velocity;\n"
"		idx+=get_global_size(0);\n"
"	}\n"
"}\n"
"";
const string OpenCLKernelSources::customGBValuePerParticle = "/**\n"
" * Reduce a pairwise computed value, and compute per-particle values.\n"
" */\n"
"\n"
"__kernel void computePerParticleValues(int bufferSize, int numBuffers, __global float4* posq,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* valueBuffers\n"
"#else\n"
"        __global float* valueBuffers\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    unsigned int index = get_global_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        // Reduce the pairwise value\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        float sum = (1.0f/0xFFFFFFFF)*valueBuffers[index];\n"
"#else\n"
"        int totalSize = bufferSize*numBuffers;\n"
"        float sum = valueBuffers[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += valueBuffers[i];\n"
"#endif\n"
"        \n"
"        // Now calculate other values\n"
"\n"
"        float4 pos = posq[index];\n"
"        COMPUTE_VALUES\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::pme = "__kernel void updateBsplines(__global const float4* restrict posq, __global float4* restrict pmeBsplineTheta, __local float4* restrict bsplinesCache,\n"
"        __global int2* restrict pmeAtomGridIndex, float4 periodicBoxSize, float4 invPeriodicBoxSize) {\n"
"    const float4 scale = 1.0f/(PME_ORDER-1);\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        __local float4* data = &bsplinesCache[get_local_id(0)*PME_ORDER];\n"
"        float4 pos = posq[i];\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 t = (float4) ((pos.x*invPeriodicBoxSize.x)*GRID_SIZE_X,\n"
"                             (pos.y*invPeriodicBoxSize.y)*GRID_SIZE_Y,\n"
"                             (pos.z*invPeriodicBoxSize.z)*GRID_SIZE_Z, 0.0f);\n"
"        float4 dr = (float4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"        pmeAtomGridIndex[i] = (int2) (i, gridIndex.x*GRID_SIZE_Y*GRID_SIZE_Z+gridIndex.y*GRID_SIZE_Z+gridIndex.z);\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            float div = 1.0f/(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+(float4) k) *data[j-k-2] + (-dr+(float4) (j-k))*data[j-k-1]);\n"
"            data[0] = div*(- dr+1.0f)*data[0];\n"
"        }\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+(float4) j)*data[PME_ORDER-j-2] + (-dr+(float4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"        for (int j = 0; j < PME_ORDER; j++) {\n"
"            data[j].w = pos.w; // Storing the charge here improves cache coherency in the charge spreading kernel\n"
"            pmeBsplineTheta[i+j*NUM_ATOMS] = data[j];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * For each grid point, find the range of sorted atoms associated with that point.\n"
" */\n"
"__kernel void findAtomRangeForGrid(__global int2* restrict pmeAtomGridIndex, __global int* restrict pmeAtomRange, __global const float4* restrict posq, float4 periodicBoxSize, float4 invPeriodicBoxSize) {\n"
"    int start = (NUM_ATOMS*get_global_id(0))/get_global_size(0);\n"
"    int end = (NUM_ATOMS*(get_global_id(0)+1))/get_global_size(0);\n"
"    int last = (start == 0 ? -1 : pmeAtomGridIndex[start-1].y);\n"
"    for (int i = start; i < end; ++i) {\n"
"        int2 atomData = pmeAtomGridIndex[i];\n"
"        int gridIndex = atomData.y;\n"
"        if (gridIndex != last) {\n"
"            for (int j = last+1; j <= gridIndex; ++j)\n"
"                pmeAtomRange[j] = i;\n"
"            last = gridIndex;\n"
"        }\n"
"\n"
"        // The grid index won't be needed again.  Reuse that component to hold the z index, thus saving\n"
"        // some work in the charge spreading kernel.\n"
"\n"
"        float posz = posq[pmeAtomGridIndex[i].x].z;\n"
"        posz -= floor(posz*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        int z = ((int) ((posz*invPeriodicBoxSize.z)*GRID_SIZE_Z)) % GRID_SIZE_Z;\n"
"        pmeAtomGridIndex[i].y = z;\n"
"    }\n"
"\n"
"    // Fill in values beyond the last atom.\n"
"\n"
"    if (get_global_id(0) == get_global_size(0)-1) {\n"
"        int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        for (int j = last+1; j <= gridSize; ++j)\n"
"            pmeAtomRange[j] = NUM_ATOMS;\n"
"    }\n"
"}\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"#define BUFFER_SIZE (PME_ORDER*PME_ORDER*PME_ORDER)\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(BUFFER_SIZE, 1, 1)))\n"
"void gridSpreadCharge(__global const float4* restrict posq, __global const int2* restrict pmeAtomGridIndex, __global const int* restrict pmeAtomRange,\n"
"        __global long* restrict pmeGrid, __global const float4* restrict pmeBsplineTheta, float4 periodicBoxSize, float4 invPeriodicBoxSize) {\n"
"    int ix = get_local_id(0)/(PME_ORDER*PME_ORDER);\n"
"    int remainder = get_local_id(0)-ix*PME_ORDER*PME_ORDER;\n"
"    int iy = remainder/PME_ORDER;\n"
"    int iz = remainder-iy*PME_ORDER;\n"
"    __local float4 theta[PME_ORDER];\n"
"    __local float charge[BUFFER_SIZE];\n"
"    __local int basex[BUFFER_SIZE];\n"
"    __local int basey[BUFFER_SIZE];\n"
"    __local int basez[BUFFER_SIZE];\n"
"    if (ix < PME_ORDER) {\n"
"        for (int baseIndex = get_group_id(0)*BUFFER_SIZE; baseIndex < NUM_ATOMS; baseIndex += get_num_groups(0)*BUFFER_SIZE) {\n"
"            // Load the next block of atoms into the buffers.\n"
"\n"
"            if (get_local_id(0) < BUFFER_SIZE) {\n"
"                int atomIndex = baseIndex+get_local_id(0);\n"
"                if (atomIndex < NUM_ATOMS) {\n"
"                    float4 pos = posq[atomIndex];\n"
"                    charge[get_local_id(0)] = pos.w;\n"
"                    pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"                    pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"                    pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"                    basex[get_local_id(0)] = (int) ((pos.x*invPeriodicBoxSize.x)*GRID_SIZE_X);\n"
"                    basey[get_local_id(0)] = (int) ((pos.y*invPeriodicBoxSize.y)*GRID_SIZE_Y);\n"
"                    basez[get_local_id(0)] = (int) ((pos.z*invPeriodicBoxSize.z)*GRID_SIZE_Z);\n"
"                }\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            int lastIndex = min(BUFFER_SIZE, NUM_ATOMS-baseIndex);\n"
"            for (int index = 0; index < lastIndex; index++) {\n"
"                int atomIndex = index+baseIndex;\n"
"                if (get_local_id(0) < PME_ORDER)\n"
"                    theta[get_local_id(0)] = pmeBsplineTheta[atomIndex+get_local_id(0)*NUM_ATOMS];\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"                float add = charge[index]*theta[ix].x*theta[iy].y*theta[iz].z;\n"
"                int x = basex[index]+ix;\n"
"                int y = basey[index]+iy;\n"
"                int z = basez[index]+iz;\n"
"                x -= (x >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"                y -= (y >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                z -= (z >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                atom_add(&pmeGrid[x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z], (long) (add*0xFFFFFFFF));\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"__kernel void finishSpreadCharge(__global long* restrict pmeGrid) {\n"
"    __global float2* floatGrid = (__global float2*) pmeGrid;\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    float scale = EPSILON_FACTOR/(float) 0xFFFFFFFF;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        long value = pmeGrid[index];\n"
"        float2 floatValue = (float2) ((float) (value*scale), 0.0f);\n"
"        floatGrid[index] = floatValue;\n"
"    }\n"
"}\n"
"#else\n"
"__kernel void gridSpreadCharge(__global const float4* restrict posq, __global const int2* restrict pmeAtomGridIndex, __global const int* restrict pmeAtomRange,\n"
"        __global float2* restrict pmeGrid, __global const float4* restrict pmeBsplineTheta) {\n"
"    unsigned int numGridPoints = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    for (int gridIndex = get_global_id(0); gridIndex < numGridPoints; gridIndex += get_global_size(0)) {\n"
"        // Compute the charge on a grid point.\n"
"\n"
"        int4 gridPoint;\n"
"        gridPoint.x = gridIndex/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = gridIndex-gridPoint.x*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        gridPoint.y = remainder/GRID_SIZE_Z;\n"
"        gridPoint.z = remainder-gridPoint.y*GRID_SIZE_Z;\n"
"        float result = 0.0f;\n"
"\n"
"        // Loop over all atoms that affect this grid point.\n"
"\n"
"        for (int ix = 0; ix < PME_ORDER; ++ix) {\n"
"            int x = gridPoint.x-ix+(gridPoint.x >= ix ? 0 : GRID_SIZE_X);\n"
"            for (int iy = 0; iy < PME_ORDER; ++iy) {\n"
"                int y = gridPoint.y-iy+(gridPoint.y >= iy ? 0 : GRID_SIZE_Y);\n"
"                int z1 = gridPoint.z-PME_ORDER+1;\n"
"                z1 += (z1 >= 0 ? 0 : GRID_SIZE_Z);\n"
"                int z2 = (z1 < gridPoint.z ? gridPoint.z : GRID_SIZE_Z-1);\n"
"                int gridIndex1 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z1;\n"
"                int gridIndex2 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z2;\n"
"                int firstAtom = pmeAtomRange[gridIndex1];\n"
"                int lastAtom = pmeAtomRange[gridIndex2+1];\n"
"                for (int i = firstAtom; i < lastAtom; ++i)\n"
"                {\n"
"                    int2 atomData = pmeAtomGridIndex[i];\n"
"                    int atomIndex = atomData.x;\n"
"                    int z = atomData.y;\n"
"                    int iz = gridPoint.z-z+(gridPoint.z >= z ? 0 : GRID_SIZE_Z);\n"
"                    float atomCharge = pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].w;\n"
"                    result += atomCharge*pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].x*pmeBsplineTheta[atomIndex+iy*NUM_ATOMS].y*pmeBsplineTheta[atomIndex+iz*NUM_ATOMS].z;\n"
"                }\n"
"                if (z1 > gridPoint.z)\n"
"                {\n"
"                    gridIndex1 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z;\n"
"                    gridIndex2 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+gridPoint.z;\n"
"                    firstAtom = pmeAtomRange[gridIndex1];\n"
"                    lastAtom = pmeAtomRange[gridIndex2+1];\n"
"                    for (int i = firstAtom; i < lastAtom; ++i)\n"
"                    {\n"
"                        int2 atomData = pmeAtomGridIndex[i];\n"
"                        int atomIndex = atomData.x;\n"
"                        int z = atomData.y;\n"
"                        int iz = gridPoint.z-z+(gridPoint.z >= z ? 0 : GRID_SIZE_Z);\n"
"                        float atomCharge = pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].w;\n"
"                        result += atomCharge*pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].x*pmeBsplineTheta[atomIndex+iy*NUM_ATOMS].y*pmeBsplineTheta[atomIndex+iz*NUM_ATOMS].z;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        pmeGrid[gridIndex] = (float2) (result*EPSILON_FACTOR, 0.0f);\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"__kernel void reciprocalConvolution(__global float2* restrict pmeGrid, __global float* restrict energyBuffer, __global const float* restrict pmeBsplineModuliX,\n"
"        __global const float* restrict pmeBsplineModuliY, __global const float* restrict pmeBsplineModuliZ, float4 invPeriodicBoxSize, float recipScaleFactor) {\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    float energy = 0.0f;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int kx = index/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = index-kx*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        int ky = remainder/GRID_SIZE_Z;\n"
"        int kz = remainder-ky*GRID_SIZE_Z;\n"
"        if (kx == 0 && ky == 0 && kz == 0)\n"
"            continue;\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        float mhx = mx*invPeriodicBoxSize.x;\n"
"        float mhy = my*invPeriodicBoxSize.y;\n"
"        float mhz = mz*invPeriodicBoxSize.z;\n"
"        float bx = pmeBsplineModuliX[kx];\n"
"        float by = pmeBsplineModuliY[ky];\n"
"        float bz = pmeBsplineModuliZ[kz];\n"
"        float2 grid = pmeGrid[index];\n"
"        float m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"        float denom = m2*bx*by*bz;\n"
"        float eterm = recipScaleFactor*EXP(-RECIP_EXP_FACTOR*m2)/denom;\n"
"        pmeGrid[index] = (float2) (grid.x*eterm, grid.y*eterm);\n"
"        energy += eterm*(grid.x*grid.x + grid.y*grid.y);\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += 0.5f*energy;\n"
"}\n"
"\n"
"__kernel void gridInterpolateForce(__global const float4* restrict posq, __global float4* restrict forceBuffers, __global const float2* restrict pmeGrid,\n"
"        float4 periodicBoxSize, float4 invPeriodicBoxSize, __local float4* restrict bsplinesCache) {\n"
"    const float4 scale = 1.0f/(PME_ORDER-1);\n"
"    __local float4* data = &bsplinesCache[get_local_id(0)*PME_ORDER];\n"
"    __local float4* ddata = &bsplinesCache[get_local_id(0)*PME_ORDER + get_local_size(0)*PME_ORDER];\n"
"    for (int atom = get_global_id(0); atom < NUM_ATOMS; atom += get_global_size(0)) {\n"
"        float4 force = 0.0f;\n"
"        float4 pos = posq[atom];\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 t = (float4) ((pos.x*invPeriodicBoxSize.x)*GRID_SIZE_X,\n"
"                             (pos.y*invPeriodicBoxSize.y)*GRID_SIZE_Y,\n"
"                             (pos.z*invPeriodicBoxSize.z)*GRID_SIZE_Z, 0.0f);\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        float4 dr = (float4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            float div = 1.0f/(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+(float4) k) *data[j-k-2] + (-dr+(float4) (j-k))*data[j-k-1]);\n"
"            data[0] = div*(- dr+1.0f)*data[0];\n"
"        }\n"
"        ddata[0] = -data[0];\n"
"        for (int j = 1; j < PME_ORDER; j++)\n"
"            ddata[j] = data[j-1]-data[j];\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+(float4) j)*data[PME_ORDER-j-2] + (-dr+(float4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"\n"
"        // Compute the force on this atom.\n"
"\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    float gridvalue = pmeGrid[index].x;\n"
"                    force.x += ddata[ix].x*data[iy].y*data[iz].z*gridvalue;\n"
"                    force.y += data[ix].x*ddata[iy].y*data[iz].z*gridvalue;\n"
"#ifndef MAC_AMD_WORKAROUND\n"
"                    force.z += data[ix].x*data[iy].y*ddata[iz].z*gridvalue;\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"#ifdef MAC_AMD_WORKAROUND\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    float gridvalue = pmeGrid[index].x;\n"
"                    force.z += data[ix].x*data[iy].y*ddata[iz].z*gridvalue;\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"        float4 totalForce = forceBuffers[atom];\n"
"        float q = pos.w*EPSILON_FACTOR;\n"
"        totalForce.x -= q*force.x*GRID_SIZE_X*invPeriodicBoxSize.x;\n"
"        totalForce.y -= q*force.y*GRID_SIZE_Y*invPeriodicBoxSize.y;\n"
"        totalForce.z -= q*force.z*GRID_SIZE_Z*invPeriodicBoxSize.z;\n"
"        forceBuffers[atom] = totalForce;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded_nvidia = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define TILE_SIZE 32\n"
"#define WARPS_PER_GROUP (FORCE_WORK_GROUP_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"#ifndef PARAMETER_SIZE_IS_EVEN\n"
"    float padding;\n"
"#endif\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"__kernel void computeNonbonded(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global float4* restrict forceBuffers,\n"
"#endif\n"
"        __global float* restrict energyBuffer, __global const float4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices,\n"
"        unsigned int startTileIndex, unsigned int endTileIndex,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = (numTiles > maxTiles ? startTileIndex+warp*(endTileIndex-startTileIndex)/totalWarps : warp*numTiles/totalWarps);\n"
"    unsigned int end = (numTiles > maxTiles ? startTileIndex+(warp+1)*(endTileIndex-startTileIndex)/totalWarps : (warp+1)*numTiles/totalWarps);\n"
"#else\n"
"    unsigned int pos = startTileIndex+warp*numTiles/totalWarps;\n"
"    unsigned int end = startTileIndex+(warp+1)*numTiles/totalWarps;\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    __local AtomData localData[FORCE_WORK_GROUP_SIZE];\n"
"    __local float tempBuffer[3*FORCE_WORK_GROUP_SIZE];\n"
"    __local unsigned int exclusionRange[2*WARPS_PER_GROUP];\n"
"    __local int exclusionIndex[WARPS_PER_GROUP];\n"
"    __local int2* reservedBlocks = (__local int2*) exclusionRange;\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        const unsigned int tbx = get_local_id(0) - tgx;\n"
"        const unsigned int localGroupIndex = get_local_id(0)/TILE_SIZE;\n"
"        unsigned int x, y;\n"
"        float4 force = 0.0f;\n"
"        if (pos < end) {\n"
"#ifdef USE_CUTOFF\n"
"            if (numTiles <= maxTiles) {\n"
"                ushort2 tileIndices = tiles[pos];\n"
"                x = tileIndices.x;\n"
"                y = tileIndices.y;\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                    y += (x < y ? -1 : 1);\n"
"                    x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                }\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            float4 posq1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"\n"
"            // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"            if (tgx < 2)\n"
"                exclusionRange[2*localGroupIndex+tgx] = exclusionRowIndices[x+tgx];\n"
"            if (tgx == 0)\n"
"                exclusionIndex[localGroupIndex] = -1;\n"
"            for (unsigned int i = exclusionRange[2*localGroupIndex]+tgx; i < exclusionRange[2*localGroupIndex+1]; i += TILE_SIZE)\n"
"                if (exclusionIndices[i] == y)\n"
"                    exclusionIndex[localGroupIndex] = i*TILE_SIZE;\n"
"            bool hasExclusions = (exclusionIndex[localGroupIndex] > -1);\n"
"#else\n"
"            bool hasExclusions = false;\n"
"#endif\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                const unsigned int localAtomIndex = get_local_id(0);\n"
"                localData[localAtomIndex].x = posq1.x;\n"
"                localData[localAtomIndex].y = posq1.y;\n"
"                localData[localAtomIndex].z = posq1.z;\n"
"                localData[localAtomIndex].q = posq1.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_1\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[exclusionIndex[localGroupIndex]+tgx];\n"
"#endif\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    int atom2 = tbx+j;\n"
"                    float4 posq2 = (float4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                    delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                    delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                    float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                    float invR = RSQRT(r2);\n"
"                    float r = RECIP(invR);\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                    float dEdR = 0.0f;\n"
"#else\n"
"                    float4 dEdR1 = (float4) 0.0f;\n"
"                    float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                    float tempEnergy = 0.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += 0.5f*tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                    force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                    force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                const unsigned int localAtomIndex = get_local_id(0);\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                localData[localAtomIndex].fx = 0.0f;\n"
"                localData[localAtomIndex].fy = 0.0f;\n"
"                localData[localAtomIndex].fz = 0.0f;\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int flags = (numTiles <= maxTiles ? interactionFlags[pos] : 0xFFFFFFFF);\n"
"                if (!hasExclusions && flags != 0xFFFFFFFF) {\n"
"                    if (flags == 0) {\n"
"                        // No interactions in this tile.\n"
"                    }\n"
"                    else {\n"
"                        // Compute only a subset of the interactions in this tile.\n"
"\n"
"                        for (j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags&(1<<j)) != 0) {\n"
"                                bool isExcluded = false;\n"
"                                int atom2 = tbx+j;\n"
"                                int bufferIndex = 3*get_local_id(0);\n"
"#ifdef USE_SYMMETRIC\n"
"                                float dEdR = 0.0f;\n"
"#else\n"
"                                float4 dEdR1 = (float4) 0.0f;\n"
"                                float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                                float tempEnergy = 0.0f;\n"
"                                float4 posq2 = (float4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                                    float invR = RSQRT(r2);\n"
"                                    float r = RECIP(invR);\n"
"                                    LOAD_ATOM2_PARAMETERS\n"
"                                    atom2 = y*TILE_SIZE+j;\n"
"                                    COMPUTE_INTERACTION\n"
"                                    energy += tempEnergy;\n"
"#ifdef USE_CUTOFF\n"
"                                }\n"
"#endif\n"
"#ifdef USE_SYMMETRIC\n"
"                                delta.xyz *= dEdR;\n"
"                                force.xyz -= delta.xyz;\n"
"                                tempBuffer[bufferIndex] = delta.x;\n"
"                                tempBuffer[bufferIndex+1] = delta.y;\n"
"                                tempBuffer[bufferIndex+2] = delta.z;\n"
"#else\n"
"                                force.xyz -= dEdR1.xyz;\n"
"                                tempBuffer[bufferIndex] = dEdR2.x;\n"
"                                tempBuffer[bufferIndex+1] = dEdR2.y;\n"
"                                tempBuffer[bufferIndex+2] = dEdR2.z;\n"
"#endif\n"
"\n"
"                                // Sum the forces on atom2.\n"
"\n"
"                                if (tgx % 4 == 0) {\n"
"                                    tempBuffer[bufferIndex] += tempBuffer[bufferIndex+3]+tempBuffer[bufferIndex+6]+tempBuffer[bufferIndex+9];\n"
"                                    tempBuffer[bufferIndex+1] += tempBuffer[bufferIndex+4]+tempBuffer[bufferIndex+7]+tempBuffer[bufferIndex+10];\n"
"                                    tempBuffer[bufferIndex+2] += tempBuffer[bufferIndex+5]+tempBuffer[bufferIndex+8]+tempBuffer[bufferIndex+11];\n"
"                                }\n"
"                                if (tgx == 0) {\n"
"                                    localData[tbx+j].fx += tempBuffer[bufferIndex]+tempBuffer[bufferIndex+12]+tempBuffer[bufferIndex+24]+tempBuffer[bufferIndex+36]+tempBuffer[bufferIndex+48]+tempBuffer[bufferIndex+60]+tempBuffer[bufferIndex+72]+tempBuffer[bufferIndex+84];\n"
"                                    localData[tbx+j].fy += tempBuffer[bufferIndex+1]+tempBuffer[bufferIndex+13]+tempBuffer[bufferIndex+25]+tempBuffer[bufferIndex+37]+tempBuffer[bufferIndex+49]+tempBuffer[bufferIndex+61]+tempBuffer[bufferIndex+73]+tempBuffer[bufferIndex+85];\n"
"                                    localData[tbx+j].fz += tempBuffer[bufferIndex+2]+tempBuffer[bufferIndex+14]+tempBuffer[bufferIndex+26]+tempBuffer[bufferIndex+38]+tempBuffer[bufferIndex+50]+tempBuffer[bufferIndex+62]+tempBuffer[bufferIndex+74]+tempBuffer[bufferIndex+86];\n"
"                                }\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"                else\n"
"#endif\n"
"                {\n"
"                    // Compute the full set of interactions in this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"                    unsigned int excl = (hasExclusions ? exclusions[exclusionIndex[localGroupIndex]+tgx] : 0xFFFFFFFF);\n"
"                    excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"                    unsigned int tj = tgx;\n"
"                    for (j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        int atom2 = tbx+tj;\n"
"                        float4 posq2 = (float4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                        float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                            float invR = RSQRT(r2);\n"
"                            float r = RECIP(invR);\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = y*TILE_SIZE+tj;\n"
"#ifdef USE_SYMMETRIC\n"
"                            float dEdR = 0.0f;\n"
"#else\n"
"                            float4 dEdR1 = (float4) 0.0f;\n"
"                            float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                            float tempEnergy = 0.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                            delta.xyz *= dEdR;\n"
"                            force.xyz -= delta.xyz;\n"
"                            localData[tbx+tj].fx += delta.x;\n"
"                            localData[tbx+tj].fy += delta.y;\n"
"                            localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                            force.xyz -= dEdR1.xyz;\n"
"                            localData[tbx+tj].fx += dEdR2.x;\n"
"                            localData[tbx+tj].fy += dEdR2.y;\n"
"                            localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        excl >>= 1;\n"
"#endif\n"
"                        tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // Write results.  We need to coordinate between warps to make sure no two of them\n"
"        // ever try to write to the same piece of memory at the same time.\n"
"        \n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        if (pos < end) {\n"
"            const unsigned int offset = x*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (force.x*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (force.y*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (force.z*0xFFFFFFFF));\n"
"        }\n"
"        if (pos < end && x != y) {\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (localData[get_local_id(0)].fx*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fy*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fz*0xFFFFFFFF));\n"
"        }\n"
"#else\n"
"        int writeX = (pos < end ? x : -1);\n"
"        int writeY = (pos < end && x != y ? y : -1);\n"
"        if (tgx == 0)\n"
"            reservedBlocks[localGroupIndex] = (int2)(writeX, writeY);\n"
"        bool done = false;\n"
"        int doneIndex = 0;\n"
"        int checkIndex = 0;\n"
"        while (true) {\n"
"            // See if any warp still needs to write its data.\n"
"\n"
"            bool allDone = true;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            while (doneIndex < WARPS_PER_GROUP && allDone) {\n"
"                if (reservedBlocks[doneIndex].x != -1)\n"
"                    allDone = false;\n"
"                else\n"
"                    doneIndex++;\n"
"            }\n"
"            if (allDone)\n"
"                break;\n"
"            if (!done) {\n"
"                // See whether this warp can write its data.  This requires that no previous warp\n"
"                // is trying to write to the same block of the buffer.\n"
"\n"
"                bool canWrite = (writeX != -1);\n"
"                while (checkIndex < localGroupIndex && canWrite) {\n"
"                    if ((reservedBlocks[checkIndex].x == x || reservedBlocks[checkIndex].y == x) ||\n"
"                            (writeY != -1 && (reservedBlocks[checkIndex].x == y || reservedBlocks[checkIndex].y == y)))\n"
"                        canWrite = false;\n"
"                    else\n"
"                        checkIndex++;\n"
"                }\n"
"                if (canWrite) {\n"
"                    // Write the data to global memory, then mark this warp as done.\n"
"\n"
"                    if (writeX > -1) {\n"
"                        const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset].xyz += force.xyz;\n"
"                    }\n"
"                    if (writeY > -1) {\n"
"                        const unsigned int offset = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset] += (float4) (localData[get_local_id(0)].fx, localData[get_local_id(0)].fy, localData[get_local_id(0)].fz, 0.0f);\n"
"                    }\n"
"                    done = true;\n"
"                    if (tgx == 0)\n"
"                        reservedBlocks[localGroupIndex] = (int2)(-1, -1);\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"        pos++;\n"
"    } while (pos < end);\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::compact = "/* Code for CUDA stream compaction. Roughly based on:\n"
"    Billeter M, Olsson O, Assarsson U. Efficient Stream Compaction on Wide SIMD Many-Core Architectures.\n"
"        High Performance Graphics 2009.\n"
"\n"
"    Notes:\n"
"        - paper recommends 128 threads/block, so this is hard coded.\n"
"        - I only implement the prefix-sum based compact primitive, and not the POPC one, as that is more\n"
"          complicated and performs poorly on current hardware\n"
"        - I only implement the scattered- and staged-write variant of phase III as it they have reasonable\n"
"          performance across most of the tested workloads in the paper. The selective variant is not\n"
"          implemented.\n"
"        - The prefix sum of per-block element counts (phase II) is not done in a particularly efficient\n"
"          manner. It is, however, done in a very easy to program manner, and integrated into the top of\n"
"          phase III, reducing the number of kernel invocations required. If one wanted to use existing code,\n"
"          it'd be easy to take the CUDA SDK scanLargeArray sample, and do a prefix sum over dgBlockCounts in\n"
"          a phase II kernel. You could also adapt the existing prescan128 to take an initial value, and scan\n"
"          dgBlockCounts in stages.\n"
"\n"
"  Date:         23 Aug 2009\n"
"  Author:       CUDA version by Imran Haque (ihaque@cs.stanford.edu), converted to OpenCL by Peter Eastman\n"
"  Affiliation:  Stanford University\n"
"  License:      Public Domain\n"
"*/\n"
"\n"
"// Phase 1: Count valid elements per thread block\n"
"// Hard-code 128 thd/blk\n"
"unsigned int sumReduce128(__local unsigned int* arr) {\n"
"    // Parallel reduce element counts\n"
"    // Assumes 128 thd/block\n"
"    int thread = get_local_id(0);\n"
"    if (thread < 64) arr[thread] += arr[thread+64];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef WARPS_ARE_ATOMIC\n"
"    if (thread < 32) {\n"
"        arr[thread] += arr[thread+32];\n"
"        if (thread < 16) arr[thread] += arr[thread+16];\n"
"        if (thread < 8) arr[thread] += arr[thread+8];\n"
"        if (thread < 4) arr[thread] += arr[thread+4];\n"
"        if (thread < 2) arr[thread] += arr[thread+2];\n"
"        if (thread < 1) arr[thread] += arr[thread+1];\n"
"    }\n"
"#else\n"
"    if (thread < 32) arr[thread] += arr[thread+32];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 16) arr[thread] += arr[thread+16];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 8) arr[thread] += arr[thread+8];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 4) arr[thread] += arr[thread+4];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 2) arr[thread] += arr[thread+2];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 1) arr[thread] += arr[thread+1];\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    return arr[0];\n"
"}\n"
"\n"
"__kernel void countElts(__global unsigned int* restrict dgBlockCounts, __global const unsigned int* restrict dgValid, const unsigned int len, __local unsigned int* restrict dsCount) {\n"
"    dsCount[get_local_id(0)] = 0;\n"
"    unsigned int ub;\n"
"    const unsigned int eltsPerBlock = len/get_num_groups(0) + ((len % get_num_groups(0)) ? 1 : 0);\n"
"    ub = (len < (get_group_id(0)+1)*eltsPerBlock) ? len : ((get_group_id(0) + 1)*eltsPerBlock);\n"
"    for (int base = get_group_id(0) * eltsPerBlock; base < (get_group_id(0)+1)*eltsPerBlock; base += get_local_size(0)) {\n"
"        if ((base + get_local_id(0)) < ub && dgValid[base+get_local_id(0)])\n"
"            dsCount[get_local_id(0)]++;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    unsigned int blockCount = sumReduce128(dsCount);\n"
"    if (get_local_id(0) == 0) dgBlockCounts[get_group_id(0)] = blockCount;\n"
"    return;\n"
"}\n"
"\n"
"// Phase 2/3: Move valid elements using SIMD compaction (phase 2 is done implicitly at top of __global__ method)\n"
"// Exclusive prefix scan over 128 elements\n"
"// Assumes 128 threads\n"
"// Taken from cuda SDK \"scan\" sample for naive scan, with small modifications\n"
"int exclusivePrescan128(__local const unsigned int* in, __local unsigned int* outAndTemp) {\n"
"    const int n=128;\n"
"    //TODO: this temp storage could be reduced since we write to shared memory in out anyway, and n is hardcoded\n"
"    //__shared__ int temp[2*n];\n"
"    __local unsigned int* temp = outAndTemp;\n"
"    int pout = 1, pin = 0;\n"
"\n"
"    // load input into temp\n"
"    // This is exclusive scan, so shift right by one and set first elt to 0\n"
"    int thread = get_local_id(0);\n"
"    temp[pout*n + get_local_id(0)] = (get_local_id(0) > 0) ? in[get_local_id(0)-1] : 0;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    for (int offset = 1; offset < n; offset *= 2)\n"
"    {\n"
"        pout = 1 - pout; // swap double buffer indices\n"
"        pin  = 1 - pout;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        temp[pout*n+get_local_id(0)] = temp[pin*n+get_local_id(0)];\n"
"        if (get_local_id(0) >= offset)\n"
"            temp[pout*n+get_local_id(0)] += temp[pin*n+get_local_id(0) - offset];\n"
"    }\n"
"\n"
"    //out[get_local_id(0)] = temp[pout*n+get_local_id(0)]; // write output\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    return outAndTemp[127]+in[127]; // Return sum of all elements\n"
"}\n"
"\n"
"int compactSIMDPrefixSum(__local const unsigned int* dsData, __local const unsigned int* dsValid, __local unsigned int* dsCompact, __local unsigned int* dsLocalIndex) {\n"
"    int numValid = exclusivePrescan128(dsValid,dsLocalIndex);\n"
"    int thread = get_local_id(0);\n"
"    if (dsValid[get_local_id(0)]) dsCompact[dsLocalIndex[get_local_id(0)]] = dsData[get_local_id(0)];\n"
"    return numValid;\n"
"}\n"
"\n"
"__kernel void moveValidElementsStaged(__global const unsigned int* restrict dgData, __global unsigned int* restrict dgCompact, __global const unsigned int* restrict dgValid,\n"
"            __global const unsigned int* restrict dgBlockCounts, unsigned int len, __global unsigned int* restrict dNumValidElements,\n"
"            __local unsigned int* restrict inBlock, __local unsigned int* restrict validBlock, __local unsigned int* restrict compactBlock) {\n"
"    __local unsigned int dsLocalIndex[256];\n"
"    int blockOutOffset=0;\n"
"    // Sum up the blockCounts before us to find our offset\n"
"    // This is totally inefficient - lots of repeated work b/w blocks, and uneven balancing.\n"
"    // Paper implements this as a prefix sum kernel in phase II\n"
"    // May still be faster than an extra kernel invocation?\n"
"    int thread = get_local_id(0);\n"
"    for (int base = 0; base < get_group_id(0); base += get_local_size(0)) {\n"
"        // Load up the count of valid elements for each block before us in batches of 128\n"
"        if ((base + get_local_id(0)) < get_group_id(0)) {\n"
"            validBlock[get_local_id(0)] = dgBlockCounts[base+get_local_id(0)];\n"
"        } else {\n"
"            validBlock[get_local_id(0)] = 0;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        // Parallel reduce these counts\n"
"        // Accumulate in the final offset variable\n"
"        blockOutOffset += sumReduce128(validBlock);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"\n"
"    unsigned int ub;\n"
"    const unsigned int eltsPerBlock = len/get_num_groups(0) + ((len % get_num_groups(0)) ? 1 : 0);\n"
"    ub = (len < (get_group_id(0)+1)*eltsPerBlock) ? len : ((get_group_id(0) + 1)*eltsPerBlock);\n"
"    for (int base = get_group_id(0) * eltsPerBlock; base < (get_group_id(0)+1)*eltsPerBlock; base += get_local_size(0)) {\n"
"        if ((base + get_local_id(0)) < ub) {\n"
"            validBlock[get_local_id(0)] = dgValid[base+get_local_id(0)];\n"
"            inBlock[get_local_id(0)] = dgData[base+get_local_id(0)];\n"
"        } else {\n"
"            validBlock[get_local_id(0)] = 0;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        int numValidBlock = compactSIMDPrefixSum(inBlock,validBlock,compactBlock,dsLocalIndex);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < numValidBlock) {\n"
"            dgCompact[blockOutOffset + get_local_id(0)] = compactBlock[get_local_id(0)];\n"
"        }\n"
"        blockOutOffset += numValidBlock;\n"
"    }\n"
"    if (get_group_id(0) == (get_num_groups(0)-1) && get_local_id(0) == 0) {\n"
"        *dNumValidElements = blockOutOffset;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::binforces = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"/**\n"
" * bin forces kernel\n"
" */\n"
"\n"
"__kernel void binForcesKernel(\n"
"			__global const float4* restrict posq,\n"
"			__global const float4* restrict binForces,\n"
"			__global const float4* restrict startPoint,\n"
"			__global const float4* restrict unitVector,\n"
"			__global float4* restrict forces,\n"
"			int nBins,\n"
"			int numAtoms\n"
"            )\n"
"{\n"
"	unsigned int idx = get_global_id(0);\n"
"	float4 sp = startPoint[0];\n"
"	float4 uv = unitVector[0];\n"
"\n"
"	if(idx<numAtoms)\n"
"	{\n"
"		float4 position = posq[idx];\n"
"                float4 rSI = position - sp;\n"
"                float rD = ((rSI.x*uv.x)+(rSI.y*uv.y)+(rSI.z*uv.z));\n"
"                int bn = (int) rD/uv.w;\n"
"                unsigned int s = bn == nBins;\n"
"                bn -= s;\n"
"		//float4 force = forces[idx];\n"
"		//force.xyz += binForces[0].xyz;\n"
"		//forces[idx] = force;\n"
"	}\n"
"}\n"
"";
const string OpenCLKernelSources::customGBEnergyPerParticle = "#define REDUCE_VALUE(NAME, TYPE) \\\n"
"    TYPE sum = NAME[index]; \\\n"
"    for (int i = index+bufferSize; i < totalSize; i += bufferSize) \\\n"
"        sum += NAME[i]; \\\n"
"    NAME[index] = sum;\n"
"\n"
"/**\n"
" * Reduce the derivatives computed in the N^2 energy kernel, and compute all per-particle energy terms.\n"
" */\n"
"\n"
"__kernel void computePerParticleEnergy(int bufferSize, int numBuffers, __global float4* restrict forceBuffers, __global float* restrict energyBuffer, __global const float4* restrict posq\n"
"        PARAMETER_ARGUMENTS) {\n"
"    float energy = 0.0f;\n"
"    unsigned int index = get_global_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        // Reduce the derivatives\n"
"\n"
"        int totalSize = bufferSize*numBuffers;\n"
"        REDUCE_DERIVATIVES\n"
"\n"
"        // Now calculate the per-particle energy terms.\n"
"\n"
"        float4 pos = posq[index];\n"
"        float4 force = (float4) 0.0f;\n"
"        COMPUTE_ENERGY\n"
"        index += get_global_size(0);\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::harmonicAngleForce = "float2 angleParams = PARAMS[index];\n"
"float4 v0 = pos2-pos1;\n"
"float4 v1 = pos2-pos3;\n"
"float4 cp = cross(v0, v1);\n"
"float rp = cp.x*cp.x + cp.y*cp.y + cp.z*cp.z;\n"
"rp = max(SQRT(rp), 1.0e-06f);\n"
"float r21 = v0.x*v0.x + v0.y*v0.y + v0.z*v0.z;\n"
"float r23 = v1.x*v1.x + v1.y*v1.y + v1.z*v1.z;\n"
"float dot = v0.x*v1.x + v0.y*v1.y + v0.z*v1.z;\n"
"float cosine = clamp(dot*RSQRT(r21*r23), -1.0f, 1.0f);\n"
"float deltaIdeal = acos(cosine)-angleParams.x;\n"
"energy += 0.5f*angleParams.y*deltaIdeal*deltaIdeal;\n"
"float dEdR = angleParams.y*deltaIdeal;\n"
"float4 force1 = cross(v0, cp)*(dEdR/(r21*rp));\n"
"float4 force3 = cross(cp, v1)*(dEdR/(r23*rp));\n"
"float4 force2 = -(force1+force3);\n"
"";
const string OpenCLKernelSources::ccma = "/**\n"
" * Compute the direction each constraint is pointing in.  This is called once at the beginning of constraint evaluation.\n"
" */\n"
"__kernel void computeConstraintDirections(__global const int2* restrict constraintAtoms, __global float4* restrict constraintDistance, __global const float4* restrict atomPositions) {\n"
"    for (int index = get_global_id(0); index < NUM_CONSTRAINTS; index += get_global_size(0)) {\n"
"        // Compute the direction for this constraint.\n"
"\n"
"        int2 atoms = constraintAtoms[index];\n"
"        float4 dir = constraintDistance[index];\n"
"        float4 oldPos1 = atomPositions[atoms.x];\n"
"        float4 oldPos2 = atomPositions[atoms.y];\n"
"        dir.x = oldPos1.x-oldPos2.x;\n"
"        dir.y = oldPos1.y-oldPos2.y;\n"
"        dir.z = oldPos1.z-oldPos2.z;\n"
"        constraintDistance[index] = dir;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compute the force applied by each constraint.\n"
" */\n"
"__kernel void computeConstraintForce(__global const int2* restrict constraintAtoms, __global const float4* restrict constraintDistance, __global const float4* restrict atomPositions,\n"
"        __global const float* restrict reducedMass, __global float* restrict delta1, __global int* restrict converged, float tol, int iteration) {\n"
"    __local int groupConverged;\n"
"    if (converged[1-iteration%2]) {\n"
"        if (get_global_id(0) == 0)\n"
"            converged[iteration%2] = 1;\n"
"        return; // The constraint iteration has already converged.\n"
"    }\n"
"    if (get_local_id(0) == 0)\n"
"        groupConverged = 1;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    float lowerTol = 1.0f-2.0f*tol+tol*tol;\n"
"    float upperTol = 1.0f+2.0f*tol+tol*tol;\n"
"    for (int index = get_global_id(0); index < NUM_CONSTRAINTS; index += get_global_size(0)) {\n"
"        // Compute the force due to this constraint.\n"
"\n"
"        int2 atoms = constraintAtoms[index];\n"
"        float4 dir = constraintDistance[index];\n"
"        float4 rp_ij = atomPositions[atoms.x]-atomPositions[atoms.y];\n"
"#ifndef CONSTRAIN_VELOCITIES\n"
"        rp_ij.xyz += dir.xyz;\n"
"#endif\n"
"        float rrpr = rp_ij.x*dir.x + rp_ij.y*dir.y + rp_ij.z*dir.z;\n"
"        float d_ij2 = dir.x*dir.x + dir.y*dir.y + dir.z*dir.z;\n"
"#ifdef CONSTRAIN_VELOCITIES\n"
"        delta1[index] = -2.0f*reducedMass[index]*rrpr/d_ij2;\n"
"\n"
"        // See whether it has converged.\n"
"\n"
"        if (groupConverged && fabs(delta1[index]) > tol) {\n"
"            groupConverged = 0;\n"
"            converged[iteration%2] = 0;\n"
"        }\n"
"#else\n"
"        float rp2 = rp_ij.x*rp_ij.x + rp_ij.y*rp_ij.y + rp_ij.z*rp_ij.z;\n"
"        float dist2 = dir.w*dir.w;\n"
"        float diff = dist2 - rp2;\n"
"        delta1[index] = (rrpr > d_ij2*1e-6f ? reducedMass[index]*diff/rrpr : 0.0f);\n"
"\n"
"        // See whether it has converged.\n"
"\n"
"        if (groupConverged && (rp2 < lowerTol*dist2 || rp2 > upperTol*dist2)) {\n"
"            groupConverged = 0;\n"
"            converged[iteration%2] = 0;\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Multiply the vector of constraint forces by the constraint matrix.\n"
" */\n"
"__kernel void multiplyByConstraintMatrix(__global const float* restrict delta1, __global float* restrict delta2, __global const int* restrict constraintMatrixColumn,\n"
"        __global const float* restrict constraintMatrixValue, __global const int* restrict converged, int iteration) {\n"
"    if (converged[iteration%2])\n"
"        return; // The constraint iteration has already converged.\n"
"\n"
"    // Multiply by the inverse constraint matrix.\n"
"\n"
"    for (int index = get_global_id(0); index < NUM_CONSTRAINTS; index += get_global_size(0)) {\n"
"        float sum = 0.0f;\n"
"        for (int i = 0; ; i++) {\n"
"            int element = index+i*NUM_CONSTRAINTS;\n"
"            int column = constraintMatrixColumn[element];\n"
"            if (column >= NUM_CONSTRAINTS)\n"
"                break;\n"
"            sum += delta1[column]*constraintMatrixValue[element];\n"
"        }\n"
"        delta2[index] = sum;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Update the atom positions based on constraint forces.\n"
" */\n"
"__kernel void updateAtomPositions(__global const int* restrict numAtomConstraints, __global const int* restrict atomConstraints, __global const float4* restrict constraintDistance,\n"
"        __global float4* restrict atomPositions, __global const float4* restrict velm, __global const float* restrict delta1, __global const float* restrict delta2, __global int* restrict converged, int iteration) {\n"
"    if (get_global_id(0) == 0)\n"
"        converged[1-iteration%2] = 1;\n"
"    if (converged[iteration%2])\n"
"        return; // The constraint iteration has already converged.\n"
"    float damping = (iteration < 2 ? 0.5f : 1.0f);\n"
"    for (int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        // Compute the new position of this atom.\n"
"\n"
"        float4 atomPos = atomPositions[index];\n"
"        float invMass = velm[index].w;\n"
"        int num = numAtomConstraints[index];\n"
"        for (int i = 0; i < num; i++) {\n"
"            int constraint = atomConstraints[index+i*NUM_ATOMS];\n"
"            bool forward = (constraint > 0);\n"
"            constraint = (forward ? constraint-1 : -constraint-1);\n"
"            float constraintForce = damping*invMass*delta2[constraint];\n"
"            constraintForce = (forward ? constraintForce : -constraintForce);\n"
"            float4 dir = constraintDistance[constraint];\n"
"            atomPos.x += constraintForce*dir.x;\n"
"            atomPos.y += constraintForce*dir.y;\n"
"            atomPos.z += constraintForce*dir.z;\n"
"        }\n"
"        atomPositions[index] = atomPos;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customGBValueN2_nvidia = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define TILE_SIZE 32\n"
"\n"
"/**\n"
" * Compute a value based on pair interactions.\n"
" */\n"
"__kernel void computeN2Value(__global const float4* restrict posq, __local float4* restrict local_posq, __global const unsigned int* restrict exclusions,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict global_value,\n"
"#else\n"
"        __global float* restrict global_value,\n"
"#endif\n"
"        __local float* restrict local_value, __local float* restrict tempBuffer,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = warp*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"    unsigned int end = (warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"#else\n"
"    unsigned int pos = warp*numTiles/totalWarps;\n"
"    unsigned int end = (warp+1)*numTiles/totalWarps;\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local unsigned int exclusionRange[2*WARPS_PER_GROUP];\n"
"    __local int exclusionIndex[WARPS_PER_GROUP];\n"
"    __local int2* reservedBlocks = (__local int2*) exclusionRange;\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        const unsigned int tbx = get_local_id(0) - tgx;\n"
"        const unsigned int localGroupIndex = get_local_id(0)/TILE_SIZE;\n"
"        unsigned int x, y;\n"
"        float value = 0.0f;\n"
"        if (pos < end) {\n"
"#ifdef USE_CUTOFF\n"
"            if (numTiles <= maxTiles) {\n"
"                ushort2 tileIndices = tiles[pos];\n"
"                x = tileIndices.x;\n"
"                y = tileIndices.y;\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                    y += (x < y ? -1 : 1);\n"
"                    x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                }\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            float4 posq1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"\n"
"            // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"            if (tgx < 2)\n"
"                exclusionRange[2*localGroupIndex+tgx] = exclusionRowIndices[x+tgx];\n"
"            if (tgx == 0)\n"
"                exclusionIndex[localGroupIndex] = -1;\n"
"            for (unsigned int i = exclusionRange[2*localGroupIndex]+tgx; i < exclusionRange[2*localGroupIndex+1]; i += TILE_SIZE)\n"
"                if (exclusionIndices[i] == y)\n"
"                    exclusionIndex[localGroupIndex] = i*TILE_SIZE;\n"
"            bool hasExclusions = (exclusionIndex[localGroupIndex] > -1);\n"
"#else\n"
"            bool hasExclusions = false;\n"
"#endif\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                const unsigned int localAtomIndex = get_local_id(0);\n"
"                local_posq[localAtomIndex] = posq1;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_1\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[exclusionIndex[localGroupIndex]+tgx];\n"
"#endif\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    int atom2 = tbx+j;\n"
"                    float4 posq2 = local_posq[atom2];\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                    delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                    delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                    float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    float invR = RSQRT(r2);\n"
"                    float r = RECIP(invR);\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    float tempValue1 = 0.0f;\n"
"                    float tempValue2 = 0.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                    if (!isExcluded && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"                        COMPUTE_VALUE\n"
"                    }\n"
"                    value += tempValue1;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                if (lasty != y) {\n"
"                    unsigned int j = y*TILE_SIZE + tgx;\n"
"                    local_posq[get_local_id(0)] = posq[j];\n"
"                    const unsigned int localAtomIndex = get_local_id(0);\n"
"                    LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                }\n"
"                local_value[get_local_id(0)] = 0.0f;\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int flags = (numTiles <= maxTiles ? interactionFlags[pos] : 0xFFFFFFFF);\n"
"                if (!hasExclusions && flags != 0xFFFFFFFF) {\n"
"                    if (flags == 0) {\n"
"                        // No interactions in this tile.\n"
"                    }\n"
"                    else {\n"
"                        // Compute only a subset of the interactions in this tile.\n"
"\n"
"                        for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags&(1<<j)) != 0) {\n"
"                                int atom2 = tbx+j;\n"
"                                float4 posq2 = local_posq[atom2];\n"
"                                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                                float tempValue1 = 0.0f;\n"
"                                float tempValue2 = 0.0f;\n"
"                                if (r2 < CUTOFF_SQUARED) {\n"
"                                    float invR = RSQRT(r2);\n"
"                                    float r = RECIP(invR);\n"
"                                    LOAD_ATOM2_PARAMETERS\n"
"                                    atom2 = y*TILE_SIZE+j;\n"
"                                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                                        COMPUTE_VALUE\n"
"                                    }\n"
"                                    value += tempValue1;\n"
"                                }\n"
"                                tempBuffer[get_local_id(0)] = tempValue2;\n"
"\n"
"                                // Sum the forces on atom2.\n"
"\n"
"                                if (tgx % 4 == 0)\n"
"                                    tempBuffer[get_local_id(0)] += tempBuffer[get_local_id(0)+1]+tempBuffer[get_local_id(0)+2]+tempBuffer[get_local_id(0)+3];\n"
"                                if (tgx == 0)\n"
"                                    local_value[tbx+j] += tempBuffer[get_local_id(0)]+tempBuffer[get_local_id(0)+4]+tempBuffer[get_local_id(0)+8]+tempBuffer[get_local_id(0)+12]+tempBuffer[get_local_id(0)+16]+tempBuffer[get_local_id(0)+20]+tempBuffer[get_local_id(0)+24]+tempBuffer[get_local_id(0)+28];\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"                else\n"
"#endif\n"
"                {\n"
"                    // Compute the full set of interactions in this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"                    unsigned int excl = (hasExclusions ? exclusions[exclusionIndex[localGroupIndex]+tgx] : 0xFFFFFFFF);\n"
"                    excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"                    unsigned int tj = tgx;\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        int atom2 = tbx+tj;\n"
"                        float4 posq2 = local_posq[atom2];\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                        float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+tj;\n"
"                        float tempValue1 = 0.0f;\n"
"                        float tempValue2 = 0.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                        if (!isExcluded && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                            COMPUTE_VALUE\n"
"                        }\n"
"                        value += tempValue1;\n"
"                        local_value[tbx+tj] += tempValue2;\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        excl >>= 1;\n"
"#endif\n"
"                        tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // Write results.  We need to coordinate between warps to make sure no two of them\n"
"        // ever try to write to the same piece of memory at the same time.\n"
"        \n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        if (pos < end) {\n"
"            const unsigned int offset = x*TILE_SIZE + tgx;\n"
"            atom_add(&global_value[offset], (long) (value*0xFFFFFFFF));\n"
"        }\n"
"        if (pos < end && x != y) {\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&global_value[offset], (long) (local_value[get_local_id(0)]*0xFFFFFFFF));\n"
"        }\n"
"#else\n"
"        int writeX = (pos < end ? x : -1);\n"
"        int writeY = (pos < end && x != y ? y : -1);\n"
"        if (tgx == 0)\n"
"            reservedBlocks[localGroupIndex] = (int2)(writeX, writeY);\n"
"        bool done = false;\n"
"        int doneIndex = 0;\n"
"        int checkIndex = 0;\n"
"        while (true) {\n"
"            // See if any warp still needs to write its data.\n"
"\n"
"            bool allDone = true;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            while (doneIndex < WARPS_PER_GROUP && allDone) {\n"
"                if (reservedBlocks[doneIndex].x != -1)\n"
"                    allDone = false;\n"
"                else\n"
"                    doneIndex++;\n"
"            }\n"
"            if (allDone)\n"
"                break;\n"
"            if (!done) {\n"
"                // See whether this warp can write its data.  This requires that no previous warp\n"
"                // is trying to write to the same block of the buffer.\n"
"\n"
"                bool canWrite = (writeX != -1);\n"
"                while (checkIndex < localGroupIndex && canWrite) {\n"
"                    if ((reservedBlocks[checkIndex].x == x || reservedBlocks[checkIndex].y == x) ||\n"
"                            (writeY != -1 && (reservedBlocks[checkIndex].x == y || reservedBlocks[checkIndex].y == y)))\n"
"                        canWrite = false;\n"
"                    else\n"
"                        checkIndex++;\n"
"                }\n"
"                if (canWrite) {\n"
"                    // Write the data to global memory, then mark this warp as done.\n"
"\n"
"                    if (writeX > -1) {\n"
"                        const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        global_value[offset] += value;\n"
"                    }\n"
"                    if (writeY > -1) {\n"
"                        const unsigned int offset = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        global_value[offset] += local_value[get_local_id(0)];\n"
"                    }\n"
"                    done = true;\n"
"                    if (tgx == 0)\n"
"                        reservedBlocks[localGroupIndex] = (int2)(-1, -1);\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"        lasty = y;\n"
"        pos++;\n"
"    } while (pos < end);\n"
"}\n"
"";
const string OpenCLKernelSources::customIntegratorPerDof = "#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"__kernel void computePerDof(__global float4* restrict posq, __global float4* restrict posDelta, __global float4* restrict velm,\n"
"        __global const float4* restrict force, __global const float2* restrict dt, __global const float* restrict globals,\n"
"        __global const float* restrict params, __global float* restrict sum, __global const float4* restrict gaussianValues,\n"
"        unsigned int randomIndex, __global const float4* restrict uniformValues, __global const float* restrict energy\n"
"        PARAMETER_ARGUMENTS) {\n"
"    float stepSize = dt[0].y;\n"
"    int index = get_global_id(0);\n"
"    randomIndex += index;\n"
"    while (index < NUM_ATOMS) {\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"#ifdef LOAD_POS_AS_DELTA\n"
"        double4 position = convert_double4(posq[index]+posDelta[index]);\n"
"#else\n"
"        double4 position = convert_double4(posq[index]);\n"
"#endif\n"
"        double4 velocity = convert_double4(velm[index]);\n"
"        double4 f = convert_double4(force[index]);\n"
"        double mass = 1.0/velocity.w;\n"
"#else\n"
"#ifdef LOAD_POS_AS_DELTA\n"
"        float4 position = posq[index]+posDelta[index];\n"
"#else\n"
"        float4 position = posq[index];\n"
"#endif\n"
"        float4 velocity = velm[index];\n"
"        float4 f = force[index];\n"
"        float mass = 1.0f/velocity.w;\n"
"#endif\n"
"        if (velocity.w != 0.0) {\n"
"            float4 gaussian = gaussianValues[randomIndex];\n"
"            float4 uniform = uniformValues[index];\n"
"            COMPUTE_STEP\n"
"        }\n"
"        randomIndex += get_global_size(0);\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customNonbonded = "#ifdef USE_CUTOFF\n"
"if (!isExcluded && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"if (!isExcluded) {\n"
"#endif\n"
"    float tempForce = 0.0f;\n"
"    COMPUTE_FORCE\n"
"    dEdR += tempForce*invR;\n"
"}\n"
"";
const string OpenCLKernelSources::customAngleForce = "float4 v0 = pos2-pos1;\n"
"float4 v1 = pos2-pos3;\n"
"float4 cp = cross(v0, v1);\n"
"float rp = cp.x*cp.x + cp.y*cp.y + cp.z*cp.z;\n"
"rp = max(sqrt(rp), 1.0e-06f);\n"
"float r21 = v0.x*v0.x + v0.y*v0.y + v0.z*v0.z;\n"
"float r23 = v1.x*v1.x + v1.y*v1.y + v1.z*v1.z;\n"
"float dot = v0.x*v1.x + v0.y*v1.y + v0.z*v1.z;\n"
"float cosine = clamp(dot/sqrt(r21*r23), -1.0f, 1.0f);\n"
"float theta = acos(cosine);\n"
"COMPUTE_FORCE\n"
"float4 force1 = cross(v0, cp)*(dEdAngle/(r21*rp));\n"
"float4 force3 = cross(cp, v1)*(dEdAngle/(r23*rp));\n"
"float4 force2 = -force1-force3;\n"
"";
const string OpenCLKernelSources::findInteractingBlocks_cpu = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"#define TILE_SIZE 32\n"
"#define GROUP_SIZE 64\n"
"#define BUFFER_GROUPS 4\n"
"#define BUFFER_SIZE BUFFER_GROUPS*GROUP_SIZE\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"__kernel void findBlockBounds(int numAtoms, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global const float4* restrict posq, __global float4* restrict blockCenter, __global float4* restrict blockBoundingBox, __global unsigned int* restrict interactionCount) {\n"
"    int index = get_global_id(0);\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        float4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 firstPoint = pos;\n"
"#endif\n"
"        float4 minPos = pos;\n"
"        float4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            pos.x -= floor((pos.x-firstPoint.x)*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"            pos.y -= floor((pos.y-firstPoint.y)*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"            pos.z -= floor((pos.z-firstPoint.z)*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"            minPos = min(minPos, pos);\n"
"            maxPos = max(maxPos, pos);\n"
"        }\n"
"        blockBoundingBox[index] = 0.5f*(maxPos-minPos);\n"
"        blockCenter[index] = 0.5f*(maxPos+minPos);\n"
"        index += get_global_size(0);\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        interactionCount[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * This is called by findBlocksWithInteractions().  It compacts the list of blocks and writes them\n"
" * to global memory.\n"
" */\n"
"void storeInteractionData(ushort2* buffer, int numValid, __global unsigned int* interactionCount, __global ushort2* interactingTiles,\n"
"            __global unsigned int* interactionFlags, float cutoffSquared, float4 periodicBoxSize, float4 invPeriodicBoxSize,\n"
"            __global float4* posq, __global float4* blockCenter, __global float4* blockBoundingBox, unsigned int maxTiles) {\n"
"    // Filter the list of tiles by comparing the distance from each atom to the other bounding box.\n"
"\n"
"    unsigned int flagsBuffer[2*BUFFER_SIZE];\n"
"    float4 atomPositions[TILE_SIZE];\n"
"    int lasty = -1;\n"
"    float4 centery, boxSizey;\n"
"    for (int tile = 0; tile < numValid; ) {\n"
"        int x = buffer[tile].x;\n"
"        int y = buffer[tile].y;\n"
"        if (x == y) {\n"
"            tile++;\n"
"            continue;\n"
"        }\n"
"\n"
"        // Load the atom positions and bounding boxes.\n"
"\n"
"        float4 centerx = blockCenter[x];\n"
"        float4 boxSizex = blockBoundingBox[x];\n"
"        if (y != lasty) {\n"
"            for (int atom = 0; atom < TILE_SIZE; atom++)\n"
"                atomPositions[atom] = posq[y*TILE_SIZE+atom];\n"
"            centery = blockCenter[y];\n"
"            boxSizey = blockBoundingBox[y];\n"
"            lasty = y;\n"
"        }\n"
"\n"
"        // Find the distance of each atom from the bounding box.\n"
"\n"
"        unsigned int flags1 = 0, flags2 = 0;\n"
"        for (int atom = 0; atom < TILE_SIZE; atom++) {\n"
"            float4 delta = atomPositions[atom]-centerx;\n"
"#ifdef USE_PERIODIC\n"
"            delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"            delta = max((float4) 0.0f, fabs(delta)-boxSizex);\n"
"            if (dot(delta.xyz, delta.xyz) < cutoffSquared)\n"
"                flags1 += 1 << atom;\n"
"            delta = posq[x*TILE_SIZE+atom]-centery;\n"
"#ifdef USE_PERIODIC\n"
"            delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"            delta = max((float4) 0.0f, fabs(delta)-boxSizey);\n"
"            if (dot(delta.xyz, delta.xyz) < cutoffSquared)\n"
"                flags2 += 1 << atom;\n"
"        }\n"
"        if (flags1 == 0 || flags2 == 0) {\n"
"            // This tile contains no interactions.\n"
"\n"
"            numValid--;\n"
"            buffer[tile] = buffer[numValid];\n"
"        }\n"
"        else {\n"
"            flagsBuffer[2*tile] = flags1;\n"
"            flagsBuffer[2*tile+1] = flags2;\n"
"            tile++;\n"
"        }\n"
"    }\n"
"\n"
"    // Store it to global memory.\n"
"\n"
"    int baseIndex = atom_add(interactionCount, numValid);\n"
"    if (baseIndex+numValid <= maxTiles)\n"
"        for (int i = 0; i < numValid; i++) {\n"
"            interactingTiles[baseIndex+i] = buffer[i];\n"
"            interactionFlags[2*(baseIndex+i)] = flagsBuffer[2*i];\n"
"            interactionFlags[2*(baseIndex+i)+1] = flagsBuffer[2*i+1];\n"
"        }\n"
"}\n"
"\n"
"/**\n"
" * Compare the bounding boxes for each pair of blocks.  If they are sufficiently far apart,\n"
" * mark them as non-interacting.\n"
" */\n"
"__kernel void findBlocksWithInteractions(float cutoffSquared, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global const float4* restrict blockCenter,\n"
"        __global const float4* restrict blockBoundingBox, __global unsigned int* restrict interactionCount, __global ushort2* restrict interactingTiles,\n"
"        __global unsigned int* restrict interactionFlags, __global const float4* restrict posq, unsigned int maxTiles, unsigned int startTileIndex,\n"
"        unsigned int endTileIndex) {\n"
"    ushort2 buffer[BUFFER_SIZE];\n"
"    int valuesInBuffer = 0;\n"
"    const int numTiles = endTileIndex-startTileIndex;\n"
"    unsigned int start = startTileIndex+get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = startTileIndex+(get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"    for (int index = start; index < end; index++) {\n"
"        // Identify the pair of blocks to compare.\n"
"\n"
"        unsigned int y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*index));\n"
"        unsigned int x = (index-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (index-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Find the distance between the bounding boxes of the two cells.\n"
"\n"
"        float4 delta = blockCenter[x]-blockCenter[y];\n"
"#ifdef USE_PERIODIC\n"
"        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"        float4 boxSizea = blockBoundingBox[x];\n"
"        float4 boxSizeb = blockBoundingBox[y];\n"
"        delta.x = max(0.0f, fabs(delta.x)-boxSizea.x-boxSizeb.x);\n"
"        delta.y = max(0.0f, fabs(delta.y)-boxSizea.y-boxSizeb.y);\n"
"        delta.z = max(0.0f, fabs(delta.z)-boxSizea.z-boxSizeb.z);\n"
"        if (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < cutoffSquared) {\n"
"            // Add this tile to the buffer.\n"
"\n"
"            buffer[valuesInBuffer++] = (ushort2) (x, y);\n"
"            if (valuesInBuffer == BUFFER_SIZE) {\n"
"                storeInteractionData(buffer, valuesInBuffer, interactionCount, interactingTiles, interactionFlags, cutoffSquared, periodicBoxSize, invPeriodicBoxSize, posq, blockCenter, blockBoundingBox, maxTiles);\n"
"                valuesInBuffer = 0;\n"
"            }\n"
"        }\n"
"    }\n"
"    storeInteractionData(buffer, valuesInBuffer, interactionCount, interactingTiles, interactionFlags, cutoffSquared, periodicBoxSize, invPeriodicBoxSize, posq, blockCenter, blockBoundingBox, maxTiles);\n"
"}\n"
"";
const string OpenCLKernelSources::brownian = "/**\n"
" * Perform the first step of Brownian integration.\n"
" */\n"
"\n"
"__kernel void integrateBrownianPart1(float tauDeltaT, float noiseAmplitude, __global const float4* restrict force,\n"
"        __global float4* restrict posDelta, __global const float4* restrict velm, __global const float4* restrict random, unsigned int randomIndex) {\n"
"    randomIndex += get_global_id(0);\n"
"    for (int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        float invMass = velm[index].w;\n"
"        if (invMass != 0.0)\n"
"            posDelta[index] = (float4) (tauDeltaT*invMass*force[index].xyz + noiseAmplitude*sqrt(invMass)*random[randomIndex].xyz, 0.0f);\n"
"        randomIndex += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of Brownian integration.\n"
" */\n"
"\n"
"__kernel void integrateBrownianPart2(float oneOverDeltaT, __global float4* posq, __global float4* velm, __global const float4* restrict posDelta) {\n"
"    for (int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        if (velm[index].w != 0.0) {\n"
"            float4 delta = posDelta[index];\n"
"            velm[index].xyz = oneOverDeltaT*delta.xyz;\n"
"            posq[index].xyz = posq[index].xyz + delta.xyz;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customGBGradientChainRule = "/**\n"
" * Compute chain rule terms for computed values that depend explicitly on particle coordinates.\n"
" */\n"
"\n"
"__kernel void computeGradientChainRuleTerms(__global float4* restrict forceBuffers, __global const float4* restrict posq\n"
"        PARAMETER_ARGUMENTS) {\n"
"    unsigned int index = get_global_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        float4 pos = posq[index];\n"
"        float4 force = forceBuffers[index];\n"
"        COMPUTE_FORCES\n"
"        forceBuffers[index] = force;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customExternalForce = "COMPUTE_FORCE\n"
"float4 force1 = (float4) (-dEdX, -dEdY, -dEdZ, 0.0f);\n"
"";
const string OpenCLKernelSources::customBondForce = "float4 delta = pos2-pos1;\n"
"float r = SQRT(delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);\n"
"COMPUTE_FORCE\n"
"delta.xyz *= -dEdR/r;\n"
"float4 force1 = -delta;\n"
"float4 force2 = delta;\n"
"";
const string OpenCLKernelSources::utilities = "/**\n"
" * Fill a buffer with 0.\n"
" */\n"
"\n"
"__kernel void clearBuffer(__global int* restrict buffer, int size) {\n"
"    int index = get_global_id(0);\n"
"    __global int4* buffer4 = (__global int4*) buffer;\n"
"    int sizeDiv4 = size/4;\n"
"    while (index < sizeDiv4) {\n"
"        buffer4[index] = (int4) 0;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        for (int i = sizeDiv4*4; i < size; i++)\n"
"            buffer[i] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Fill two buffers with 0.\n"
" */\n"
"__kernel void clearTwoBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"}\n"
"\n"
"/**\n"
" * Fill three buffers with 0.\n"
" */\n"
"__kernel void clearThreeBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"}\n"
"\n"
"/**\n"
" * Fill four buffers with 0.\n"
" */\n"
"__kernel void clearFourBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"}\n"
"\n"
"/**\n"
" * Fill five buffers with 0.\n"
" */\n"
"__kernel void clearFiveBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4, __global int* restrict buffer5, int size5) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"    clearBuffer(buffer5, size5);\n"
"}\n"
"\n"
"/**\n"
" * Fill six buffers with 0.\n"
" */\n"
"__kernel void clearSixBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4, __global int* restrict buffer5, int size5, __global int* restrict buffer6, int size6) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"    clearBuffer(buffer5, size5);\n"
"    clearBuffer(buffer6, size6);\n"
"}\n"
"\n"
"/**\n"
" * Sum a collection of buffers into the first one.\n"
" */\n"
"\n"
"__kernel void reduceFloat4Buffer(__global float4* restrict buffer, int bufferSize, int numBuffers) {\n"
"    int index = get_global_id(0);\n"
"    int totalSize = bufferSize*numBuffers;\n"
"    while (index < bufferSize) {\n"
"        float4 sum = buffer[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += buffer[i];\n"
"        buffer[index] = sum;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the various buffers containing forces.\n"
" */\n"
"__kernel void reduceForces(__global const long* restrict longBuffer, __global float4* restrict buffer, int bufferSize, int numBuffers) {\n"
"    int totalSize = bufferSize*numBuffers;\n"
"    float scale = 1.0f/(float) 0xFFFFFFFF;\n"
"    for (int index = get_global_id(0); index < bufferSize; index += get_global_size(0)) {\n"
"        float4 sum = (float4) (scale*longBuffer[index], scale*longBuffer[index+bufferSize], scale*longBuffer[index+2*bufferSize], 0.0f);\n"
"        for (int i = index; i < totalSize; i += bufferSize)\n"
"            sum += buffer[i];\n"
"        buffer[index] = sum;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * This is called to determine the accuracy of various native functions.\n"
" */\n"
"\n"
"__kernel void determineNativeAccuracy(__global float8* restrict values, int numValues) {\n"
"    for (int i = get_global_id(0); i < numValues; i += get_global_size(0)) {\n"
"        float v = values[i].s0;\n"
"        values[i] = (float8) (v, native_sqrt(v), native_rsqrt(v), native_recip(v), native_exp(v), native_log(v), 0.0f, 0.0f);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded_cpu = "#define TILE_SIZE 32\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"\n"
"__kernel void computeNonbonded(__global float4* restrict forceBuffers, __global float* restrict energyBuffer, __global const float4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices,\n"
"        unsigned int startTileIndex, unsigned int endTileIndex,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = (numTiles > maxTiles ? startTileIndex+get_group_id(0)*(endTileIndex-startTileIndex)/get_num_groups(0) : get_group_id(0)*numTiles/get_num_groups(0));\n"
"    unsigned int end = (numTiles > maxTiles ? startTileIndex+(get_group_id(0)+1)*(endTileIndex-startTileIndex)/get_num_groups(0) : (get_group_id(0)+1)*numTiles/get_num_groups(0));\n"
"#else\n"
"    unsigned int pos = startTileIndex+get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = startTileIndex+(get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData localData[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"\n"
"        // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int exclusionStart = exclusionRowIndices[x];\n"
"        unsigned int exclusionEnd = exclusionRowIndices[x+1];\n"
"        int exclusionIndex = -1;\n"
"        for (int i = exclusionStart; i < exclusionEnd; i++)\n"
"            if (exclusionIndices[i] == y) {\n"
"                exclusionIndex = i*TILE_SIZE;\n"
"                break;\n"
"            }\n"
"        bool hasExclusions = (exclusionIndex > -1);\n"
"#endif\n"
"\n"
"        // Load the data for this tile if we don't already have it cached.\n"
"\n"
"        if (lasty != y) {\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[exclusionIndex+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float4 force = 0.0f;\n"
"                float4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    float invR = RSQRT(r2);\n"
"                    float r = RECIP(invR);\n"
"                    unsigned int atom2 = j;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                    float dEdR = 0.0f;\n"
"#else\n"
"                    float4 dEdR1 = (float4) 0.0f;\n"
"                    float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                    float tempEnergy = 0.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += 0.5f*tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                    force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                    force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    excl >>= 1;\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"                unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                localData[tgx].fx = 0.0f;\n"
"                localData[tgx].fy = 0.0f;\n"
"                localData[tgx].fz = 0.0f;\n"
"            }\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int flags1 = (numTiles <= maxTiles ? interactionFlags[2*pos] : 0xFFFFFFFF);\n"
"            unsigned int flags2 = (numTiles <= maxTiles ? interactionFlags[2*pos+1] : 0xFFFFFFFF);\n"
"            if (!hasExclusions && (flags1 != 0xFFFFFFFF || flags2 != 0xFFFFFFFF)) {\n"
"                // Compute only a subset of the interactions in this tile.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    if ((flags2&(1<<tgx)) != 0) {\n"
"                        unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                        float4 force = 0.0f;\n"
"                        float4 posq1 = posq[atom1];\n"
"                        LOAD_ATOM1_PARAMETERS\n"
"                        for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags1&(1<<j)) != 0) {\n"
"                                bool isExcluded = false;\n"
"                                float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                                float r2 = dot(delta.xyz, delta.xyz);\n"
"                                if (r2 < CUTOFF_SQUARED) {\n"
"                                    float invR = RSQRT(r2);\n"
"                                    float r = RECIP(invR);\n"
"                                    unsigned int atom2 = j;\n"
"                                    LOAD_ATOM2_PARAMETERS\n"
"                                    atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                                    float dEdR = 0.0f;\n"
"#else\n"
"                                    float4 dEdR1 = (float4) 0.0f;\n"
"                                    float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                                    float tempEnergy = 0.0f;\n"
"                                    COMPUTE_INTERACTION\n"
"                                    energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                                    delta.xyz *= dEdR;\n"
"                                    force.xyz -= delta.xyz;\n"
"                                    localData[j].fx += delta.x;\n"
"                                    localData[j].fy += delta.y;\n"
"                                    localData[j].fz += delta.z;\n"
"#else\n"
"                                    force.xyz -= dEdR1.xyz;\n"
"                                    localData[j].fx += dEdR2.x;\n"
"                                    localData[j].fy += dEdR2.y;\n"
"                                    localData[j].fz += dEdR2.z;\n"
"#endif\n"
"                                }\n"
"                            }\n"
"                        }\n"
"\n"
"                        // Write results for atom1.\n"
"\n"
"                        unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"                    }\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // Compute the full set of interactions in this tile.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    float4 force = 0.0f;\n"
"                    float4 posq1 = posq[atom1];\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"                    unsigned int excl = (hasExclusions ? exclusions[exclusionIndex+tgx] : 0xFFFFFFFF);\n"
"#endif\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                        float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                        float dEdR = 0.0f;\n"
"#else\n"
"                        float4 dEdR1 = (float4) 0.0f;\n"
"                        float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                        float tempEnergy = 0.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[j].fx += delta.x;\n"
"                        localData[j].fy += delta.y;\n"
"                        localData[j].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[j].fx += dEdR2.x;\n"
"                        localData[j].fy += dEdR2.y;\n"
"                        localData[j].fz += dEdR2.z;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        excl >>= 1;\n"
"#endif\n"
"                    }\n"
"\n"
"                   // Write results for atom1.\n"
"\n"
"                    unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int offset = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                float4 f = forceBuffers[offset];\n"
"                f.x += localData[tgx].fx;\n"
"                f.y += localData[tgx].fy;\n"
"                f.z += localData[tgx].fz;\n"
"                forceBuffers[offset] = f;\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::langevin = "#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"enum {VelScale, ForceScale, NoiseScale, MaxParams};\n"
"\n"
"/**\n"
" * Perform the first step of Langevin integration.\n"
" */\n"
"\n"
"__kernel void integrateLangevinPart1(__global float4* restrict velm, __global const float4* restrict force, __global float4* restrict posDelta,\n"
"        __global const float* restrict paramBuffer, __global const float2* restrict dt, __global const float4* restrict random, unsigned int randomIndex) {\n"
"    float vscale = paramBuffer[VelScale];\n"
"    float fscale = paramBuffer[ForceScale];\n"
"    float noisescale = paramBuffer[NoiseScale];\n"
"    float stepSize = dt[0].y;\n"
"    int index = get_global_id(0);\n"
"    randomIndex += index;\n"
"    while (index < NUM_ATOMS) {\n"
"        float4 velocity = velm[index];\n"
"        if (velocity.w != 0.0) {\n"
"            float sqrtInvMass = sqrt(velocity.w);\n"
"            velocity.xyz = vscale*velocity.xyz + fscale*velocity.w*force[index].xyz + noisescale*sqrtInvMass*random[randomIndex].xyz;\n"
"            velm[index] = velocity;\n"
"            posDelta[index] = stepSize*velocity;\n"
"        }\n"
"        randomIndex += get_global_size(0);\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of Langevin integration.\n"
" */\n"
"\n"
"__kernel void integrateLangevinPart2(__global float4* restrict posq, __global const float4* restrict posDelta, __global float4* restrict velm, __global const float2* restrict dt) {\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"    double invStepSize = 1.0/dt[0].y;\n"
"#else\n"
"    float invStepSize = 1.0f/dt[0].y;\n"
"#endif\n"
"    int index = get_global_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        float4 vel = velm[index];\n"
"        if (vel.w != 0.0) {\n"
"            float4 pos = posq[index];\n"
"            float4 delta = posDelta[index];\n"
"            pos.xyz += delta.xyz;\n"
"#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"            vel.xyz = convert_float4(invStepSize*convert_double4(delta)).xyz;\n"
"#else\n"
"            vel.xyz = invStepSize*delta.xyz;\n"
"#endif\n"
"            posq[index] = pos;\n"
"            velm[index] = vel;\n"
"        }\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Select the step size to use for the next step.\n"
" */\n"
"\n"
"__kernel void selectLangevinStepSize(float maxStepSize, float errorTol, float tau, float kT, __global float2* restrict dt,\n"
"        __global const float4* restrict velm, __global const float4* restrict force, __global float* restrict paramBuffer, __local float* restrict params, __local float* restrict error) {\n"
"    // Calculate the error.\n"
"\n"
"    float err = 0.0f;\n"
"    unsigned int index = get_local_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        float4 f = force[index];\n"
"        float invMass = velm[index].w;\n"
"        err += (f.x*f.x + f.y*f.y + f.z*f.z)*invMass;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    error[get_local_id(0)] = err;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Sum the errors from all threads.\n"
"\n"
"    for (unsigned int offset = 1; offset < get_local_size(0); offset *= 2) {\n"
"        if (get_local_id(0)+offset < get_local_size(0) && (get_local_id(0)&(2*offset-1)) == 0)\n"
"            error[get_local_id(0)] += error[get_local_id(0)+offset];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    if (get_global_id(0) == 0) {\n"
"        // Select the new step size.\n"
"\n"
"        float totalError = sqrt(error[0]/(NUM_ATOMS*3));\n"
"        float newStepSize = sqrt(errorTol/totalError);\n"
"        float oldStepSize = dt[0].y;\n"
"        if (oldStepSize > 0.0f)\n"
"            newStepSize = min(newStepSize, oldStepSize*2.0f); // For safety, limit how quickly dt can increase.\n"
"        if (newStepSize > oldStepSize && newStepSize < 1.1f*oldStepSize)\n"
"            newStepSize = oldStepSize; // Keeping dt constant between steps improves the behavior of the integrator.\n"
"        if (newStepSize > maxStepSize)\n"
"            newStepSize = maxStepSize;\n"
"        dt[0].y = newStepSize;\n"
"\n"
"        // Recalculate the integration parameters.\n"
"\n"
"        float vscale = exp(-newStepSize/tau);\n"
"        float fscale = (1-vscale)*tau;\n"
"        float noisescale = sqrt(2*kT/tau)*sqrt(0.5f*(1-vscale*vscale)*tau);\n"
"        params[VelScale] = vscale;\n"
"        params[ForceScale] = fscale;\n"
"        params[NoiseScale] = noisescale;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (get_local_id(0) < MaxParams)\n"
"        paramBuffer[get_local_id(0)] = params[get_local_id(0)];\n"
"}\n"
"";
const string OpenCLKernelSources::ewald = "\n"
"float2 multofFloat2(float2 a, float2 b) {\n"
"    return (float2) (a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
"}\n"
"\n"
"/**\n"
" * Precompute the cosine and sine sums which appear in each force term.\n"
" */\n"
"\n"
"__kernel void calculateEwaldCosSinSums(__global float* restrict energyBuffer, __global const float4* restrict posq, __global float2* restrict cosSinSum, float4 reciprocalPeriodicBoxSize, float reciprocalCoefficient) {\n"
"    const unsigned int ksizex = 2*KMAX_X-1;\n"
"    const unsigned int ksizey = 2*KMAX_Y-1;\n"
"    const unsigned int ksizez = 2*KMAX_Z-1;\n"
"    const unsigned int totalK = ksizex*ksizey*ksizez;\n"
"    unsigned int index = get_global_id(0);\n"
"    float energy = 0.0f;\n"
"    while (index < (KMAX_Y-1)*ksizez+KMAX_Z)\n"
"        index += get_global_size(0);\n"
"    while (index < totalK) {\n"
"        // Find the wave vector (kx, ky, kz) this index corresponds to.\n"
"\n"
"        int rx = index/(ksizey*ksizez);\n"
"        int remainder = index - rx*ksizey*ksizez;\n"
"        int ry = remainder/ksizez;\n"
"        int rz = remainder - ry*ksizez - KMAX_Z + 1;\n"
"        ry += -KMAX_Y + 1;\n"
"        float kx = rx*reciprocalPeriodicBoxSize.x;\n"
"        float ky = ry*reciprocalPeriodicBoxSize.y;\n"
"        float kz = rz*reciprocalPeriodicBoxSize.z;\n"
"\n"
"        // Compute the sum for this wave vector.\n"
"\n"
"        float2 sum = 0.0f;\n"
"        for (int atom = 0; atom < NUM_ATOMS; atom++) {\n"
"            float4 apos = posq[atom];\n"
"            float phase = apos.x*kx;\n"
"            float2 structureFactor = (float2) (cos(phase), sin(phase));\n"
"            phase = apos.y*ky;\n"
"            structureFactor = multofFloat2(structureFactor, (float2) (cos(phase), sin(phase)));\n"
"            phase = apos.z*kz;\n"
"            structureFactor = multofFloat2(structureFactor, (float2) (cos(phase), sin(phase)));\n"
"            sum += apos.w*structureFactor;\n"
"        }\n"
"        cosSinSum[index] = sum;\n"
"\n"
"        // Compute the contribution to the energy.\n"
"\n"
"        float k2 = kx*kx + ky*ky + kz*kz;\n"
"        float ak = EXP(k2*EXP_COEFFICIENT) / k2;\n"
"        energy += reciprocalCoefficient*ak*(sum.x*sum.x + sum.y*sum.y);\n"
"        index += get_global_size(0);\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Compute the reciprocal space part of the Ewald force, using the precomputed sums from the\n"
" * previous routine.\n"
" */\n"
"\n"
"__kernel void calculateEwaldForces(__global float4* restrict forceBuffers, __global const float4* restrict posq, __global const float2* restrict cosSinSum, float4 reciprocalPeriodicBoxSize, float reciprocalCoefficient) {\n"
"    unsigned int atom = get_global_id(0);\n"
"    while (atom < NUM_ATOMS) {\n"
"        float4 force = forceBuffers[atom];\n"
"        float4 apos = posq[atom];\n"
"\n"
"        // Loop over all wave vectors.\n"
"\n"
"        int lowry = 0;\n"
"        int lowrz = 1;\n"
"        for (int rx = 0; rx < KMAX_X; rx++) {\n"
"            float kx = rx*reciprocalPeriodicBoxSize.x;\n"
"            for (int ry = lowry; ry < KMAX_Y; ry++) {\n"
"                float ky = ry*reciprocalPeriodicBoxSize.y;\n"
"                float phase = apos.x*kx;\n"
"                float2 tab_xy = (float2) (cos(phase), sin(phase));\n"
"                phase = apos.y*ky;\n"
"                tab_xy = multofFloat2(tab_xy, (float2) (cos(phase), sin(phase)));\n"
"                for (int rz = lowrz; rz < KMAX_Z; rz++) {\n"
"                    float kz = rz*reciprocalPeriodicBoxSize.z;\n"
"\n"
"                    // Compute the force contribution of this wave vector.\n"
"\n"
"                    int index = rx*(KMAX_Y*2-1)*(KMAX_Z*2-1) + (ry+KMAX_Y-1)*(KMAX_Z*2-1) + (rz+KMAX_Z-1);\n"
"                    float k2 = kx*kx + ky*ky + kz*kz;\n"
"                    float ak = EXP(k2*EXP_COEFFICIENT)/k2;\n"
"                    phase = apos.z*kz;\n"
"                    float2 structureFactor = multofFloat2(tab_xy, (float2) (cos(phase), sin(phase)));\n"
"                    float2 sum = cosSinSum[index];\n"
"                    float dEdR = 2*reciprocalCoefficient*ak*apos.w*(sum.x*structureFactor.y - sum.y*structureFactor.x);\n"
"                    force.x += dEdR*kx;\n"
"                    force.y += dEdR*ky;\n"
"                    force.z += dEdR*kz;\n"
"                    lowrz = 1 - KMAX_Z;\n"
"                }\n"
"                lowry = 1 - KMAX_Y;\n"
"            }\n"
"        }\n"
"\n"
"        // Record the force on the atom.\n"
"\n"
"        forceBuffers[atom] = force;\n"
"        atom += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::gbsaObc_cpu = "#define TILE_SIZE 32\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float radius, scaledRadius;\n"
"    float bornSum;\n"
"} AtomData1;\n"
"\n"
"/**\n"
" * Compute the Born sum.\n"
" */\n"
"\n"
"__kernel void computeBornSum(__global float* restrict global_bornSum, __global const float4* restrict posq, __global const float2* restrict global_params,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags) {\n"
"#else\n"
"        unsigned int numTiles) {\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData1 localData[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"\n"
"        // Load the data for this tile if we don't already have it cached.\n"
"\n"
"        if (lasty != y) {\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                float2 tempParams = global_params[j];\n"
"                localData[localAtomIndex].radius = tempParams.x;\n"
"                localData[localAtomIndex].scaledRadius = tempParams.y;\n"
"            }\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float bornSum = 0.0f;\n"
"                float4 posq1 = posq[atom1];\n"
"                float2 params1 = global_params[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        float2 params2 = (float2) (localData[j].radius, localData[j].scaledRadius);\n"
"                        float rScaledRadiusJ = r+params2.y;\n"
"                        if ((j != tgx) && (params1.x < rScaledRadiusJ)) {\n"
"                            float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                            float u_ij = RECIP(rScaledRadiusJ);\n"
"                            float l_ij2 = l_ij*l_ij;\n"
"                            float u_ij2 = u_ij*u_ij;\n"
"                            float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + 0.25f*r*(u_ij2-l_ij2) + (0.50f*invR*ratio) +\n"
"                                             (0.25f*params2.y*params2.y*invR)*(l_ij2-u_ij2);\n"
"                            if (params1.x < params2.y-r)\n"
"                                bornSum += 2.0f*(RECIP(params1.x)-l_ij);\n"
"                        }\n"
"                    }\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"                unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_bornSum[offset] += bornSum;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++)\n"
"                localData[tgx].bornSum = 0.0f;\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float bornSum = 0.0f;\n"
"                float4 posq1 = posq[atom1];\n"
"                float2 params1 = global_params[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"\n"
"\n"
"                        float2 params2 = (float2) (localData[j].radius, localData[j].scaledRadius);\n"
"                        float rScaledRadiusJ = r+params2.y;\n"
"                        if (params1.x < rScaledRadiusJ) {\n"
"                            float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                            float u_ij = RECIP(rScaledRadiusJ);\n"
"                            float l_ij2 = l_ij*l_ij;\n"
"                            float u_ij2 = u_ij*u_ij;\n"
"                            float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + 0.25f*r*(u_ij2-l_ij2) + (0.50f*invR*ratio) +\n"
"                                             (0.25f*params2.y*params2.y*invR)*(l_ij2-u_ij2);\n"
"                            if (params1.x < params2.y-r)\n"
"                                bornSum += 2.0f*(RECIP(params1.x)-l_ij);\n"
"                        }\n"
"                        float rScaledRadiusI = r+params1.y;\n"
"                        if (params2.x < rScaledRadiusI) {\n"
"                            float l_ij = RECIP(max(params2.x, fabs(r-params1.y)));\n"
"                            float u_ij = RECIP(rScaledRadiusI);\n"
"                            float l_ij2 = l_ij*l_ij;\n"
"                            float u_ij2 = u_ij*u_ij;\n"
"                            float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            float term = l_ij - u_ij + 0.25f*r*(u_ij2-l_ij2) + (0.50f*invR*ratio) +\n"
"                                             (0.25f*params1.y*params1.y*invR)*(l_ij2-u_ij2);\n"
"                            if (params2.x < params1.y-r)\n"
"                                term += 2.0f*(RECIP(params2.x)-l_ij);\n"
"                            localData[j].bornSum += term;\n"
"                        }\n"
"                    }\n"
"                }\n"
"\n"
"               // Write results for atom1.\n"
"\n"
"                unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_bornSum[offset] += bornSum;\n"
"            }\n"
"\n"
"            // Write results\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int offset = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                global_bornSum[offset] += localData[tgx].bornSum;\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"}\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float fx, fy, fz, fw;\n"
"    float bornRadius;\n"
"} AtomData2;\n"
"\n"
"/**\n"
" * First part of computing the GBSA interaction.\n"
" */\n"
"\n"
"__kernel void computeGBSAForce1(__global float4* restrict forceBuffers, __global float* restrict global_bornForce,\n"
"        __global float* restrict energyBuffer, __global const float4* restrict posq, __global const float* restrict global_bornRadii,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags) {\n"
"#else\n"
"        unsigned int numTiles) {\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData2 localData[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"\n"
"        // Load the data for this tile if we don't already have it cached.\n"
"\n"
"        if (lasty != y) {\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                localData[localAtomIndex].bornRadius = global_bornRadii[j];\n"
"            }\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float4 force = 0.0f;\n"
"                float4 posq1 = posq[atom1];\n"
"                float bornRadius1 = global_bornRadii[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        float bornRadius2 = localData[j].bornRadius;\n"
"                        float alpha2_ij = bornRadius1*bornRadius2;\n"
"                        float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        float expTerm = EXP(-D_ij);\n"
"                        float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        float denominator = SQRT(denominator2);\n"
"                        float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                        float Gpol = tempEnergy*RECIP(denominator2);\n"
"                        float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"                        float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        energy += 0.5f*tempEnergy;\n"
"                        force.xyz -= delta.xyz*dEdR;\n"
"                    }\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"                unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"                global_bornForce[offset] += force.w;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                localData[tgx].fx = 0.0f;\n"
"                localData[tgx].fy = 0.0f;\n"
"                localData[tgx].fz = 0.0f;\n"
"                localData[tgx].fw = 0.0f;\n"
"            }\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float4 force = 0.0f;\n"
"                float4 posq1 = posq[atom1];\n"
"                float bornRadius1 = global_bornRadii[atom1];\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    float4 posq2 = (float4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        float bornRadius2 = localData[j].bornRadius;\n"
"                        float alpha2_ij = bornRadius1*bornRadius2;\n"
"                        float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        float expTerm = EXP(-D_ij);\n"
"                        float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        float denominator = SQRT(denominator2);\n"
"                        float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                        float Gpol = tempEnergy*RECIP(denominator2);\n"
"                        float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"                        float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        energy += tempEnergy;\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[j].fx += delta.x;\n"
"                        localData[j].fy += delta.y;\n"
"                        localData[j].fz += delta.z;\n"
"                        localData[j].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"                    }\n"
"                }\n"
"\n"
"                // Write results for atom1.\n"
"\n"
"                unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"                global_bornForce[offset] += force.w;\n"
"            }\n"
"\n"
"            // Write results\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int offset = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                float4 f = forceBuffers[offset];\n"
"                f.x += localData[tgx].fx;\n"
"                f.y += localData[tgx].fy;\n"
"                f.z += localData[tgx].fz;\n"
"                forceBuffers[offset] = f;\n"
"                global_bornForce[offset] += localData[tgx].fw;\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::periodicTorsionForce = "const float PI = 3.14159265358979323846f;\n"
"float4 torsionParams = PARAMS[index];\n"
"float4 v0 = (float4) (pos1.xyz-pos2.xyz, 0.0f);\n"
"float4 v1 = (float4) (pos3.xyz-pos2.xyz, 0.0f);\n"
"float4 v2 = (float4) (pos3.xyz-pos4.xyz, 0.0f);\n"
"float4 cp0 = cross(v0, v1);\n"
"float4 cp1 = cross(v1, v2);\n"
"float cosangle = dot(normalize(cp0), normalize(cp1));\n"
"float dihedralAngle;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    float4 cross_prod = cross(cp0, cp1);\n"
"    float scale = dot(cp0, cp0)*dot(cp1, cp1);\n"
"    dihedralAngle = asin(sqrt(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        dihedralAngle = PI-dihedralAngle;\n"
"}\n"
"else\n"
"   dihedralAngle = acos(cosangle);\n"
"dihedralAngle = (dot(v0, cp1) >= 0 ? dihedralAngle : -dihedralAngle);\n"
"float deltaAngle = torsionParams.z*dihedralAngle-torsionParams.y;\n"
"energy += torsionParams.x*(1.0f+cos(deltaAngle));\n"
"float sinDeltaAngle = sin(deltaAngle);\n"
"float dEdAngle = -torsionParams.x*torsionParams.z*sinDeltaAngle;\n"
"float normCross1 = dot(cp0, cp0);\n"
"float normSqrBC = dot(v1, v1);\n"
"float normBC = sqrt(normSqrBC);\n"
"float normCross2 = dot(cp1, cp1);\n"
"float dp = 1.0f/normSqrBC;\n"
"float4 ff = (float4) ((-dEdAngle*normBC)/normCross1, dot(v0, v1)*dp, dot(v2, v1)*dp, (dEdAngle*normBC)/normCross2);\n"
"float4 force1 = ff.x*cp0;\n"
"float4 force4 = ff.w*cp1;\n"
"float4 s = ff.y*force1 - ff.z*force4;\n"
"float4 force2 = s-force1;\n"
"float4 force3 = -s-force4;";
const string OpenCLKernelSources::pme_cpu = "__kernel void updateBsplines(__global const float4* restrict posq, __global float4* restrict pmeBsplineTheta, __local float4* restrict bsplinesCache, __global int2* restrict pmeAtomGridIndex, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global float4* restrict pmeBsplineDTheta) {\n"
"    const float4 scale = 1.0f/(PME_ORDER-1);\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        __local float4* data = &bsplinesCache[get_local_id(0)*PME_ORDER];\n"
"        __local float4* ddata = &bsplinesCache[get_local_id(0)*PME_ORDER + get_local_size(0)*PME_ORDER];\n"
"        for (int j = 0; j < PME_ORDER; j++) {\n"
"	    data[j] = 0.0f;\n"
"            ddata[j] = 0.0f;\n"
"        }\n"
"        float4 pos = posq[i];\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 t = (float4) ((pos.x*invPeriodicBoxSize.x)*GRID_SIZE_X,\n"
"                             (pos.y*invPeriodicBoxSize.y)*GRID_SIZE_Y,\n"
"                             (pos.z*invPeriodicBoxSize.z)*GRID_SIZE_Z, 0.0f);\n"
"        float4 dr = (float4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            float div = 1.0f/(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+(float4) k) *data[j-k-2] + (-dr+(float4) (j-k))*data[j-k-1]);\n"
"            data[0] = div*(- dr+1.0f)*data[0];\n"
"        }\n"
"        ddata[0] = -data[0];\n"
"        for (int j = 1; j < PME_ORDER; j++)\n"
"            ddata[j] = data[j-1]-data[j];\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+(float4) j)*data[PME_ORDER-j-2] + (-dr+(float4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"        for (int j = 0; j < PME_ORDER; j++) {\n"
"            pmeBsplineTheta[i+j*NUM_ATOMS] = data[j];\n"
"            pmeBsplineDTheta[i+j*NUM_ATOMS] = ddata[j];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * This kernel is not actually used when running on a CPU.\n"
" */\n"
"__kernel void findAtomRangeForGrid(__global const int2* restrict pmeAtomGridIndex, __global int* restrict pmeAtomRange, __global const float4* restrict posq, float4 periodicBoxSize, float4 invPeriodicBoxSize) {\n"
"}\n"
"\n"
"__kernel void gridSpreadCharge(__global const float4* restrict posq, __global const int2* restrict pmeAtomGridIndex, __global const int* restrict pmeAtomRange, __global float2* restrict pmeGrid, __global const float4* restrict pmeBsplineTheta, float4 periodicBoxSize, float4 invPeriodicBoxSize) {\n"
"    const int firstx = get_global_id(0)*GRID_SIZE_X/get_global_size(0);\n"
"    const int lastx = (get_global_id(0)+1)*GRID_SIZE_X/get_global_size(0);\n"
"    for (int gridIndex = firstx*GRID_SIZE_Y*GRID_SIZE_Z; gridIndex < lastx*GRID_SIZE_Y*GRID_SIZE_Z; gridIndex++)\n"
"        pmeGrid[gridIndex] = (float2) (0.0f, 0.0f);\n"
"    for (int atom = 0; atom < NUM_ATOMS; atom++) {\n"
"        float4 pos = posq[atom];\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 t = (float4) ((pos.x*invPeriodicBoxSize.x)*GRID_SIZE_X,\n"
"                             (pos.y*invPeriodicBoxSize.y)*GRID_SIZE_Y,\n"
"                             (pos.z*invPeriodicBoxSize.z)*GRID_SIZE_Z, 0.0f);\n"
"        float4 dr = (float4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"        float atomCharge = pos.w*EPSILON_FACTOR;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            if (xindex < firstx || xindex >= lastx)\n"
"                continue;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                for(int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    pmeGrid[index].x += atomCharge*pmeBsplineTheta[atom+ix*NUM_ATOMS].x*pmeBsplineTheta[atom+iy*NUM_ATOMS].y*pmeBsplineTheta[atom+iz*NUM_ATOMS].z;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"__kernel void reciprocalConvolution(__global float2* restrict pmeGrid, __global float* restrict energyBuffer, __global const float* restrict pmeBsplineModuliX,\n"
"        __global const float* restrict pmeBsplineModuliY, __global const float* restrict pmeBsplineModuliZ, float4 invPeriodicBoxSize, float recipScaleFactor) {\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    float energy = 0.0f;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int kx = index/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = index-kx*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        int ky = remainder/GRID_SIZE_Z;\n"
"        int kz = remainder-ky*GRID_SIZE_Z;\n"
"        if (kx == 0 && ky == 0 && kz == 0)\n"
"            continue;\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        float mhx = mx*invPeriodicBoxSize.x;\n"
"        float mhy = my*invPeriodicBoxSize.y;\n"
"        float mhz = mz*invPeriodicBoxSize.z;\n"
"        float bx = pmeBsplineModuliX[kx];\n"
"        float by = pmeBsplineModuliY[ky];\n"
"        float bz = pmeBsplineModuliZ[kz];\n"
"        float2 grid = pmeGrid[index];\n"
"        float m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"        float denom = m2*bx*by*bz;\n"
"        float eterm = recipScaleFactor*EXP(-RECIP_EXP_FACTOR*m2)/denom;\n"
"        pmeGrid[index] = (float2) (grid.x*eterm, grid.y*eterm);\n"
"        energy += eterm*(grid.x*grid.x + grid.y*grid.y);\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += 0.5f*energy;\n"
"}\n"
"\n"
"__kernel void gridInterpolateForce(__global const float4* restrict posq, __global float4* restrict forceBuffers, __global const float2* restrict pmeGrid, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global const float4* restrict pmeBsplineTheta, __global const float4* restrict pmeBsplineDTheta) {\n"
"    for (int atom = get_global_id(0); atom < NUM_ATOMS; atom += get_global_size(0)) {\n"
"        float4 force = 0.0f;\n"
"        float4 pos = posq[atom];\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 t = (float4) ((pos.x*invPeriodicBoxSize.x)*GRID_SIZE_X,\n"
"                             (pos.y*invPeriodicBoxSize.y)*GRID_SIZE_Y,\n"
"                             (pos.z*invPeriodicBoxSize.z)*GRID_SIZE_Z, 0.0f);\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            float tx = pmeBsplineTheta[atom+ix*NUM_ATOMS].x;\n"
"            float dtx = pmeBsplineDTheta[atom+ix*NUM_ATOMS].x;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                float ty = pmeBsplineTheta[atom+iy*NUM_ATOMS].y;\n"
"                float dty = pmeBsplineDTheta[atom+iy*NUM_ATOMS].y;\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    float tz = pmeBsplineTheta[atom+iz*NUM_ATOMS].z;\n"
"                    float dtz = pmeBsplineDTheta[atom+iz*NUM_ATOMS].z;\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    float gridvalue = pmeGrid[index].x;\n"
"                    force.x += dtx*ty*tz*gridvalue;\n"
"                    force.y += tx*dty*tz*gridvalue;\n"
"                    force.z += tx*ty*dtz*gridvalue;\n"
"                }\n"
"            }\n"
"        }\n"
"        float4 totalForce = forceBuffers[atom];\n"
"        float q = pos.w*EPSILON_FACTOR;\n"
"        totalForce.x -= q*force.x*GRID_SIZE_X*invPeriodicBoxSize.x;\n"
"        totalForce.y -= q*force.y*GRID_SIZE_Y*invPeriodicBoxSize.y;\n"
"        totalForce.z -= q*force.z*GRID_SIZE_Z*invPeriodicBoxSize.z;\n"
"        forceBuffers[atom] = totalForce;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::gbsaObc_default = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define TILE_SIZE 32\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float radius, scaledRadius;\n"
"} AtomData1;\n"
"\n"
"/**\n"
" * Compute the Born sum.\n"
" */\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(FORCE_WORK_GROUP_SIZE, 1, 1)))\n"
"void computeBornSum(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict global_bornSum,\n"
"#else\n"
"        __global float* restrict global_bornSum,\n"
"#endif\n"
"        __global const float4* restrict posq, __global const float2* restrict global_params,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles) {\n"
"#else\n"
"        unsigned int numTiles) {\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData1 localData[TILE_SIZE];\n"
"    __local float localBornSum[FORCE_WORK_GROUP_SIZE];\n"
"    __local float localTemp[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"        unsigned int baseLocalAtom = (get_local_id(0) < TILE_SIZE ? 0 : TILE_SIZE/2);\n"
"        unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        unsigned int localForceOffset = get_local_id(0) & ~(TILE_SIZE-1);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        float bornSum = 0.0f;\n"
"        float4 posq1 = posq[atom1];\n"
"        float2 params1 = global_params[atom1];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"                localData[get_local_id(0)].x = posq1.x;\n"
"                localData[get_local_id(0)].y = posq1.y;\n"
"                localData[get_local_id(0)].z = posq1.z;\n"
"                localData[get_local_id(0)].radius = params1.x;\n"
"                localData[get_local_id(0)].scaledRadius = params1.y;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"                float4 delta = (float4) (localData[baseLocalAtom+j].x-posq1.x, localData[baseLocalAtom+j].y-posq1.y, localData[baseLocalAtom+j].z-posq1.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                float2 params2 = (float2) (localData[baseLocalAtom+j].radius, localData[baseLocalAtom+j].scaledRadius);\n"
"                float rScaledRadiusJ = r+params2.y;\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int includeInteraction = (atom1 < NUM_ATOMS && y*TILE_SIZE+baseLocalAtom+j < NUM_ATOMS && r2 < CUTOFF_SQUARED && (j+baseLocalAtom != tgx) && (params1.x < rScaledRadiusJ));\n"
"#else\n"
"                unsigned int includeInteraction = (atom1 < NUM_ATOMS && y*TILE_SIZE+baseLocalAtom+j < NUM_ATOMS && (j+baseLocalAtom != tgx) && (params1.x < rScaledRadiusJ));\n"
"#endif\n"
"                float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                float u_ij = RECIP(rScaledRadiusJ);\n"
"                float l_ij2 = l_ij*l_ij;\n"
"                float u_ij2 = u_ij*u_ij;\n"
"                float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                bornSum += select(0.0f, l_ij - u_ij + 0.25f*r*(u_ij2-l_ij2) + (0.50f*invR*ratio) +\n"
"                                 (0.25f*params2.y*params2.y*invR)*(l_ij2-u_ij2), includeInteraction);\n"
"                bornSum += select(0.0f, 2.0f*(RECIP(params1.x)-l_ij), includeInteraction && params1.x < params2.y-r);\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE)\n"
"                localTemp[tgx] = bornSum;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset = x*TILE_SIZE + tgx;\n"
"                atom_add(&global_bornSum[offset], (long) ((bornSum + localTemp[tgx])*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset = x*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                global_bornSum[offset] += bornSum + localTemp[tgx];\n"
"#endif\n"
"            }\n"
"            // barrier not required here as localTemp is not accessed before encountering another barrier.\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            if (lasty != y && get_local_id(0) < TILE_SIZE) {\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[get_local_id(0)].x = tempPosq.x;\n"
"                localData[get_local_id(0)].y = tempPosq.y;\n"
"                localData[get_local_id(0)].z = tempPosq.z;\n"
"                float2 tempParams = global_params[j];\n"
"                localData[get_local_id(0)].radius = tempParams.x;\n"
"                localData[get_local_id(0)].scaledRadius = tempParams.y;\n"
"            }\n"
"            localBornSum[get_local_id(0)] = 0.0f;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = (tgx+baseLocalAtom) & (TILE_SIZE-1);\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"                float4 delta = (float4) (localData[tj].x-posq1.x, localData[tj].y-posq1.y, localData[tj].z-posq1.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int includeInteraction = (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"                unsigned int includeInteraction = (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS);\n"
"#endif\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                float2 params2 = (float2) (localData[tj].radius, localData[tj].scaledRadius);\n"
"                float rScaledRadiusJ = r+params2.y;\n"
"                {\n"
"                    float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                    float u_ij = RECIP(rScaledRadiusJ);\n"
"                    float l_ij2 = l_ij*l_ij;\n"
"                    float u_ij2 = u_ij*u_ij;\n"
"                    float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                    unsigned int includeTerm = (includeInteraction && params1.x < rScaledRadiusJ);\n"
"                    bornSum += select(0.0f, l_ij - u_ij + 0.25f*r*(u_ij2-l_ij2) + (0.50f*invR*ratio) +\n"
"                                     (0.25f*params2.y*params2.y*invR)*(l_ij2-u_ij2), includeTerm);\n"
"                    bornSum += select(0.0f, 2.0f*(RECIP(params1.x)-l_ij), includeTerm && params1.x < params2.y-r);\n"
"                }\n"
"                float rScaledRadiusI = r+params1.y;\n"
"                {\n"
"                    float l_ij = RECIP(max(params2.x, fabs(r-params1.y)));\n"
"                    float u_ij = RECIP(rScaledRadiusI);\n"
"                    float l_ij2 = l_ij*l_ij;\n"
"                    float u_ij2 = u_ij*u_ij;\n"
"                    float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                    float term = l_ij - u_ij + 0.25f*r*(u_ij2-l_ij2) + (0.50f*invR*ratio) +\n"
"                                     (0.25f*params1.y*params1.y*invR)*(l_ij2-u_ij2);\n"
"                    term += select(0.0f, 2.0f*(RECIP(params2.x)-l_ij), params2.x < params1.y-r);\n"
"                    localBornSum[tj+localForceOffset] += select(0.0f, term, includeInteraction && params2.x < rScaledRadiusI);\n"
"                }\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"                tj = (tj+1) & (TILE_SIZE-1);\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE)\n"
"                localTemp[tgx] = bornSum;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"                atom_add(&global_bornSum[offset1], (long) ((bornSum + localTemp[tgx])*0xFFFFFFFF));\n"
"                atom_add(&global_bornSum[offset2], (long) ((localBornSum[get_local_id(0)] + localBornSum[get_local_id(0)+TILE_SIZE])*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + y*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                // Do both loads before both stores to minimize store-load waits.\n"
"                float sum1 = global_bornSum[offset1];\n"
"                float sum2 = global_bornSum[offset2];\n"
"                sum1 += bornSum + localTemp[tgx];\n"
"                sum2 += localBornSum[get_local_id(0)] + localBornSum[get_local_id(0)+TILE_SIZE];\n"
"                global_bornSum[offset1] = sum1;\n"
"                global_bornSum[offset2] = sum2;\n"
"#endif\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"}\n"
"\n"
"typedef struct {\n"
"    float x, y, z, w;\n"
"    float padding;\n"
"} PaddedUnalignedFloat4;\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float bornRadius;\n"
"    float temp_x, temp_y, temp_z, temp_w;\n"
"} AtomData2;\n"
"\n"
"/**\n"
" * First part of computing the GBSA interaction.\n"
" */\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(FORCE_WORK_GROUP_SIZE, 1, 1)))\n"
"void computeGBSAForce1(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers, __global long* restrict global_bornForce,\n"
"#else\n"
"        __global float4* restrict forceBuffers, __global float* restrict global_bornForce,\n"
"#endif\n"
"        __global float* restrict energyBuffer, __global const float4* restrict posq, __global const float* restrict global_bornRadii,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles) {\n"
"#else\n"
"        unsigned int numTiles) {\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData2 localData[TILE_SIZE];\n"
"    __local PaddedUnalignedFloat4 localForce[FORCE_WORK_GROUP_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"        unsigned int baseLocalAtom = (get_local_id(0) < TILE_SIZE ? 0 : TILE_SIZE/2);\n"
"        unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        unsigned int localForceOffset = get_local_id(0) & ~(TILE_SIZE-1);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        float4 force = 0.0f;\n"
"        float4 posq1 = posq[atom1];\n"
"        float bornRadius1 = global_bornRadii[atom1];\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"                localData[get_local_id(0)].x = posq1.x;\n"
"                localData[get_local_id(0)].y = posq1.y;\n"
"                localData[get_local_id(0)].z = posq1.z;\n"
"                localData[get_local_id(0)].q = posq1.w;\n"
"                localData[get_local_id(0)].bornRadius = bornRadius1;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"                unsigned int includeInteraction = (atom1 < NUM_ATOMS && y*TILE_SIZE+baseLocalAtom+j < NUM_ATOMS);\n"
"                float4 posq2 = (float4) (localData[baseLocalAtom+j].x, localData[baseLocalAtom+j].y, localData[baseLocalAtom+j].z, localData[baseLocalAtom+j].q);\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                float bornRadius2 = localData[baseLocalAtom+j].bornRadius;\n"
"                float alpha2_ij = bornRadius1*bornRadius2;\n"
"                float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                float expTerm = EXP(-D_ij);\n"
"                float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                float denominator = SQRT(denominator2);\n"
"                float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                float Gpol = tempEnergy*RECIP(denominator2);\n"
"                float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"#ifdef USE_CUTOFF\n"
"                dEdR = select(dEdR, 0.0f, r2 > CUTOFF_SQUARED);\n"
"                tempEnergy = select(tempEnergy, 0.0f, r2 > CUTOFF_SQUARED);\n"
"                dGpol_dalpha2_ij = select(dGpol_dalpha2_ij, 0.0f, r2 > CUTOFF_SQUARED);\n"
"#endif\n"
"                force.w += select(0.0f, dGpol_dalpha2_ij*bornRadius2, includeInteraction);\n"
"                energy += select(0.0f, 0.5f*tempEnergy, includeInteraction);\n"
"                delta.xyz *= select(0.0f, dEdR, includeInteraction);\n"
"                force.xyz -= delta.xyz;\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE) {\n"
"                localData[tgx].temp_x = force.x;\n"
"                localData[tgx].temp_y = force.y;\n"
"                localData[tgx].temp_z = force.z;\n"
"                localData[tgx].temp_w = force.w;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset = x*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset], (long) ((force.x + localData[tgx].temp_x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) ((force.y + localData[tgx].temp_y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) ((force.z + localData[tgx].temp_z)*0xFFFFFFFF));\n"
"                atom_add(&global_bornForce[offset], (long) ((force.w + localData[tgx].temp_w)*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset = x*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                // Cheaper to load/store float4 than float3. Do all loads before all stores to minimize store-load waits.\n"
"                float4 sum = forceBuffers[offset];\n"
"                float global_sum = global_bornForce[offset];\n"
"                sum.x += force.x + localData[tgx].temp_x;\n"
"                sum.y += force.y + localData[tgx].temp_y;\n"
"                sum.z += force.z + localData[tgx].temp_z;\n"
"                global_sum += force.w + localData[tgx].temp_w;\n"
"                forceBuffers[offset] = sum;\n"
"                global_bornForce[offset] = global_sum;\n"
"#endif\n"
"            }\n"
"            // barrier not required here as localData[*]/temp_* is not accessed before encountering another barrier.\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            if (lasty != y && get_local_id(0) < TILE_SIZE) {\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[get_local_id(0)].x = tempPosq.x;\n"
"                localData[get_local_id(0)].y = tempPosq.y;\n"
"                localData[get_local_id(0)].z = tempPosq.z;\n"
"                localData[get_local_id(0)].q = tempPosq.w;\n"
"                localData[get_local_id(0)].bornRadius = global_bornRadii[j];\n"
"            }\n"
"            localForce[get_local_id(0)].x = 0.0f;\n"
"            localForce[get_local_id(0)].y = 0.0f;\n"
"            localForce[get_local_id(0)].z = 0.0f;\n"
"            localForce[get_local_id(0)].w = 0.0f;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = (tgx+baseLocalAtom) & (TILE_SIZE-1);\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"                unsigned int includeInteraction = (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS);\n"
"                float4 posq2 = (float4) (localData[tj].x, localData[tj].y, localData[tj].z, localData[tj].q);\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                float bornRadius2 = localData[tj].bornRadius;\n"
"                float alpha2_ij = bornRadius1*bornRadius2;\n"
"                float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                float expTerm = EXP(-D_ij);\n"
"                float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                float denominator = SQRT(denominator2);\n"
"                float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                float Gpol = tempEnergy*RECIP(denominator2);\n"
"                float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"#ifdef USE_CUTOFF\n"
"                dEdR = select(dEdR, 0.0f, r2 > CUTOFF_SQUARED);\n"
"                tempEnergy = select(tempEnergy, 0.0f, r2 > CUTOFF_SQUARED);\n"
"                dGpol_dalpha2_ij = select(dGpol_dalpha2_ij, 0.0f, r2 > CUTOFF_SQUARED);\n"
"#endif\n"
"                force.w += select(0.0f, dGpol_dalpha2_ij*bornRadius2, includeInteraction);\n"
"                energy += select(0.0f, tempEnergy, includeInteraction);\n"
"                delta.xyz *= select(0.0f, dEdR, includeInteraction);\n"
"                force.xyz -= delta.xyz;\n"
"                localForce[tj+localForceOffset].x += delta.x;\n"
"                localForce[tj+localForceOffset].y += delta.y;\n"
"                localForce[tj+localForceOffset].z += delta.z;\n"
"                localForce[tj+localForceOffset].w += select(0.0f, dGpol_dalpha2_ij*bornRadius1, includeInteraction);\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"                tj = (tj+1) & (TILE_SIZE-1);\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE) {\n"
"                localData[tgx].temp_x = force.x;\n"
"                localData[tgx].temp_y = force.y;\n"
"                localData[tgx].temp_z = force.z;\n"
"                localData[tgx].temp_w = force.w;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset1], (long) ((force.x + localData[tgx].temp_x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+PADDED_NUM_ATOMS], (long) ((force.y + localData[tgx].temp_y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+2*PADDED_NUM_ATOMS], (long) ((force.z + localData[tgx].temp_z)*0xFFFFFFFF));\n"
"                atom_add(&global_bornForce[offset1], (long) ((force.w + localData[tgx].temp_w)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2], (long) ((localData[get_local_id(0)].fx + localForce[get_local_id(0)+TILE_SIZE].x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2+PADDED_NUM_ATOMS], (long) ((localData[get_local_id(0)].fy + localForce[get_local_id(0)+TILE_SIZE].y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2+2*PADDED_NUM_ATOMS], (long) ((localData[get_local_id(0)].fz + localForce[get_local_id(0)+TILE_SIZE].z)*0xFFFFFFFF));\n"
"                atom_add(&global_bornForce[offset2], (long) ((localData[get_local_id(0)].fw + localForce[get_local_id(0)+TILE_SIZE].w)*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + y*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                // Cheaper to load/store float4 than float3. Do all loads before all stores to minimize store-load waits.\n"
"                float4 sum1 = forceBuffers[offset1];\n"
"                float4 sum2 = forceBuffers[offset2];\n"
"                float global_sum1 = global_bornForce[offset1];\n"
"                float global_sum2 = global_bornForce[offset2];\n"
"                sum1.x += force.x + localData[tgx].temp_x;\n"
"                sum1.y += force.y + localData[tgx].temp_y;\n"
"                sum1.z += force.z + localData[tgx].temp_z;\n"
"                global_sum1 += force.w + localData[tgx].temp_w;\n"
"                sum2.x += localForce[get_local_id(0)].x + localForce[get_local_id(0)+TILE_SIZE].x;\n"
"                sum2.y += localForce[get_local_id(0)].y + localForce[get_local_id(0)+TILE_SIZE].y;\n"
"                sum2.z += localForce[get_local_id(0)].z + localForce[get_local_id(0)+TILE_SIZE].z;\n"
"                global_sum2 += localForce[get_local_id(0)].w + localForce[get_local_id(0)+TILE_SIZE].w;\n"
"                forceBuffers[offset1] = sum1;\n"
"                forceBuffers[offset2] = sum2;\n"
"                global_bornForce[offset1] = global_sum1;\n"
"                global_bornForce[offset2] = global_sum2;\n"
"#endif\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::cmapTorsionForce = "const float PI = 3.14159265358979323846f;\n"
"\n"
"// Compute the first angle.\n"
"\n"
"float4 v0a = (float4) (pos1.xyz-pos2.xyz, 0.0f);\n"
"float4 v1a = (float4) (pos3.xyz-pos2.xyz, 0.0f);\n"
"float4 v2a = (float4) (pos3.xyz-pos4.xyz, 0.0f);\n"
"float4 cp0a = cross(v0a, v1a);\n"
"float4 cp1a = cross(v1a, v2a);\n"
"float cosangle = dot(normalize(cp0a), normalize(cp1a));\n"
"float angleA;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    float4 cross_prod = cross(cp0a, cp1a);\n"
"    float scale = dot(cp0a, cp0a)*dot(cp1a, cp1a);\n"
"    angleA = asin(SQRT(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        angleA = PI-angleA;\n"
"}\n"
"else\n"
"   angleA = acos(cosangle);\n"
"angleA = (dot(v0a, cp1a) >= 0 ? angleA : -angleA);\n"
"angleA = fmod(angleA+2.0f*PI, 2.0f*PI);\n"
"\n"
"// Compute the second angle.\n"
"\n"
"float4 v0b = (float4) (pos5.xyz-pos6.xyz, 0.0f);\n"
"float4 v1b = (float4) (pos7.xyz-pos6.xyz, 0.0f);\n"
"float4 v2b = (float4) (pos7.xyz-pos8.xyz, 0.0f);\n"
"float4 cp0b = cross(v0b, v1b);\n"
"float4 cp1b = cross(v1b, v2b);\n"
"cosangle = dot(normalize(cp0b), normalize(cp1b));\n"
"float angleB;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    float4 cross_prod = cross(cp0b, cp1b);\n"
"    float scale = dot(cp0b, cp0b)*dot(cp1b, cp1b);\n"
"    angleB = asin(SQRT(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        angleB = PI-angleB;\n"
"}\n"
"else\n"
"   angleB = acos(cosangle);\n"
"angleB = (dot(v0b, cp1b) >= 0 ? angleB : -angleB);\n"
"angleB = fmod(angleB+2.0f*PI, 2.0f*PI);\n"
"\n"
"// Identify which patch this is in.\n"
"\n"
"int2 pos = MAP_POS[MAPS[index]];\n"
"int size = pos.y;\n"
"float delta = 2*PI/size;\n"
"int s = (int) (angleA/delta);\n"
"int t = (int) (angleB/delta);\n"
"float4 c[4];\n"
"int coeffIndex = pos.x+4*(s+size*t);\n"
"c[0] = COEFF[coeffIndex];\n"
"c[1] = COEFF[coeffIndex+1];\n"
"c[2] = COEFF[coeffIndex+2];\n"
"c[3] = COEFF[coeffIndex+3];\n"
"float da = angleA/delta-s;\n"
"float db = angleB/delta-t;\n"
"\n"
"// Evaluate the spline to determine the energy and gradients.\n"
"\n"
"float torsionEnergy = 0.0f;\n"
"float dEdA = 0.0f;\n"
"float dEdB = 0.0f;\n"
"torsionEnergy = da*torsionEnergy + ((c[3].w*db + c[3].z)*db + c[3].y)*db + c[3].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].w*da + 2.0f*c[2].w)*da + c[1].w;\n"
"dEdB = da*dEdB + (3.0f*c[3].w*db + 2.0f*c[3].z)*db + c[3].y;\n"
"torsionEnergy = da*torsionEnergy + ((c[2].w*db + c[2].z)*db + c[2].y)*db + c[2].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].z*da + 2.0f*c[2].z)*da + c[1].z;\n"
"dEdB = da*dEdB + (3.0f*c[2].w*db + 2.0f*c[2].z)*db + c[2].y;\n"
"torsionEnergy = da*torsionEnergy + ((c[1].w*db + c[1].z)*db + c[1].y)*db + c[1].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].y*da + 2.0f*c[2].y)*da + c[1].y;\n"
"dEdB = da*dEdB + (3.0f*c[1].w*db + 2.0f*c[1].z)*db + c[1].y;\n"
"torsionEnergy = da*torsionEnergy + ((c[0].w*db + c[0].z)*db + c[0].y)*db + c[0].x;\n"
"dEdA = db*dEdA + (3.0f*c[3].x*da + 2.0f*c[2].x)*da + c[1].x;\n"
"dEdB = da*dEdB + (3.0f*c[0].w*db + 2.0f*c[0].z)*db + c[0].y;\n"
"dEdA /= delta;\n"
"dEdB /= delta;\n"
"energy += torsionEnergy;\n"
"\n"
"// Apply the force to the first torsion.\n"
"\n"
"float normCross1 = dot(cp0a, cp0a);\n"
"float normSqrBC = dot(v1a, v1a);\n"
"float normBC = SQRT(normSqrBC);\n"
"float normCross2 = dot(cp1a, cp1a);\n"
"float dp = 1.0f/normSqrBC;\n"
"float4 ff = (float4) ((-dEdA*normBC)/normCross1, dot(v0a, v1a)*dp, dot(v2a, v1a)*dp, (dEdA*normBC)/normCross2);\n"
"float4 force1 = ff.x*cp0a;\n"
"float4 force4 = ff.w*cp1a;\n"
"float4 d = ff.y*force1 - ff.z*force4;\n"
"float4 force2 = d-force1;\n"
"float4 force3 = -d-force4;\n"
"\n"
"// Apply the force to the second torsion.\n"
"\n"
"normCross1 = dot(cp0b, cp0b);\n"
"normSqrBC = dot(v1b, v1b);\n"
"normBC = SQRT(normSqrBC);\n"
"normCross2 = dot(cp1b, cp1b);\n"
"dp = 1.0f/normSqrBC;\n"
"ff = (float4) ((-dEdB*normBC)/normCross1, dot(v0b, v1b)*dp, dot(v2b, v1b)*dp, (dEdB*normBC)/normCross2);\n"
"float4 force5 = ff.x*cp0b;\n"
"float4 force8 = ff.w*cp1b;\n"
"d = ff.y*force5 - ff.z*force8;\n"
"float4 force6 = d-force5;\n"
"float4 force7 = -d-force8;\n"
"";
const string OpenCLKernelSources::gbsaObc2 = "{\n"
"    float invRSquaredOver4 = 0.25f*invR*invR;\n"
"    float rScaledRadiusJ = r+obcParams2.y;\n"
"    float rScaledRadiusI = r+obcParams1.y;\n"
"    float l_ijJ = RECIP(max(obcParams1.x, fabs(r-obcParams2.y)));\n"
"    float l_ijI = RECIP(max(obcParams2.x, fabs(r-obcParams1.y)));\n"
"    float u_ijJ = RECIP(rScaledRadiusJ);\n"
"    float u_ijI = RECIP(rScaledRadiusI);\n"
"    float l_ij2J = l_ijJ*l_ijJ;\n"
"    float l_ij2I = l_ijI*l_ijI;\n"
"    float u_ij2J = u_ijJ*u_ijJ;\n"
"    float u_ij2I = u_ijI*u_ijI;\n"
"    float t1J = LOG(u_ijJ*RECIP(l_ijJ));\n"
"    float t1I = LOG(u_ijI*RECIP(l_ijI));\n"
"    float t2J = (l_ij2J-u_ij2J);\n"
"    float t2I = (l_ij2I-u_ij2I);\n"
"    float term1 = (0.5f*(0.25f+obcParams2.y*obcParams2.y*invRSquaredOver4)*t2J + t1J*invRSquaredOver4)*invR;\n"
"    float term2 = (0.5f*(0.25f+obcParams1.y*obcParams1.y*invRSquaredOver4)*t2I + t1I*invRSquaredOver4)*invR;\n"
"    float tempdEdR = select(0.0f, bornForce1*term1, obcParams1.x < rScaledRadiusJ);\n"
"    tempdEdR += select(0.0f, bornForce2*term2, obcParams2.x < rScaledRadiusI);\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int includeInteraction = (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2 && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"    unsigned int includeInteraction = (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2);\n"
"#endif\n"
"    dEdR += select(0.0f, tempdEdR, includeInteraction);\n"
"}\n"
"";
const string OpenCLKernelSources::monteCarloBarostat = "/**\n"
" * Scale the particle positions.\n"
" */\n"
"\n"
"__kernel void scalePositions(float scale, int numMolecules, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global float4* restrict posq,\n"
"        __global const int* restrict moleculeAtoms, __global const int* restrict moleculeStartIndex) {\n"
"    for (int index = get_global_id(0); index < numMolecules; index += get_global_size(0)) {\n"
"        int first = moleculeStartIndex[index];\n"
"        int last = moleculeStartIndex[index+1];\n"
"        int numAtoms = last-first;\n"
"\n"
"        // Find the center of each molecule.\n"
"\n"
"        float4 center = (float4) 0.0f;\n"
"        for (int atom = first; atom < last; atom++)\n"
"            center += posq[moleculeAtoms[atom]];\n"
"        center /= (float) numAtoms;\n"
"\n"
"        // Move it into the first periodic box.\n"
"\n"
"        int xcell = (int) floor(center.x*invPeriodicBoxSize.x);\n"
"        int ycell = (int) floor(center.y*invPeriodicBoxSize.y);\n"
"        int zcell = (int) floor(center.z*invPeriodicBoxSize.z);\n"
"        float4 delta = (float4) (xcell*periodicBoxSize.x, ycell*periodicBoxSize.y, zcell*periodicBoxSize.z, 0);\n"
"        center -= delta;\n"
"\n"
"        // Now scale the position of the molecule center.\n"
"\n"
"        delta = center*(scale-1)-delta;\n"
"        for (int atom = first; atom < last; atom++) {\n"
"            float4 pos = posq[moleculeAtoms[atom]];\n"
"            pos.xyz += delta.xyz;\n"
"            posq[moleculeAtoms[atom]] = pos;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customIntegratorGlobal = "__kernel void computeGlobal(__global float2* restrict dt, __global float* restrict globals, __global float* restrict params,\n"
"        float uniform, float gaussian, __global const float* restrict energy) {\n"
"    COMPUTE_STEP\n"
"}\n"
"";
const string OpenCLKernelSources::gbsaObc_nvidia = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define TILE_SIZE 32\n"
"#define WARPS_PER_GROUP (FORCE_WORK_GROUP_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float radius, scaledRadius;\n"
"    float bornSum;\n"
"} AtomData1;\n"
"\n"
"/**\n"
" * Compute the Born sum.\n"
" */\n"
"__kernel void computeBornSum(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict global_bornSum,\n"
"#else\n"
"        __global float* restrict global_bornSum,\n"
"#endif\n"
"        __global const float4* restrict posq, __global const float2* restrict global_params,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags,\n"
"#else\n"
"        unsigned int numTiles,\n"
"#endif\n"
"        __global unsigned int* exclusionIndices, __global unsigned int* exclusionRowIndices) {\n"
"    unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = warp*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"    unsigned int end = (warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"#else\n"
"    unsigned int pos = warp*numTiles/totalWarps;\n"
"    unsigned int end = (warp+1)*numTiles/totalWarps;\n"
"#endif\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData1 localData[FORCE_WORK_GROUP_SIZE];\n"
"    __local float tempBuffer[FORCE_WORK_GROUP_SIZE];\n"
"    __local int2 reservedBlocks[WARPS_PER_GROUP];\n"
"    __local unsigned int* exclusionRange = (__local unsigned int*) reservedBlocks;\n"
"    __local int exclusionIndex[WARPS_PER_GROUP];\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        const unsigned int tbx = get_local_id(0) - tgx;\n"
"        const unsigned int localGroupIndex = get_local_id(0)/TILE_SIZE;\n"
"        unsigned int x, y;\n"
"        float bornSum = 0.0f;\n"
"        if (pos < end) {\n"
"#ifdef USE_CUTOFF\n"
"            if (numTiles <= maxTiles) {\n"
"                ushort2 tileIndices = tiles[pos];\n"
"                x = tileIndices.x;\n"
"                y = tileIndices.y;\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                    y += (x < y ? -1 : 1);\n"
"                    x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                }\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            float4 posq1 = posq[atom1];\n"
"            float2 params1 = global_params[atom1];\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                localData[get_local_id(0)].x = posq1.x;\n"
"                localData[get_local_id(0)].y = posq1.y;\n"
"                localData[get_local_id(0)].z = posq1.z;\n"
"                localData[get_local_id(0)].q = posq1.w;\n"
"                localData[get_local_id(0)].radius = params1.x;\n"
"                localData[get_local_id(0)].scaledRadius = params1.y;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    float4 delta = (float4) (localData[tbx+j].x-posq1.x, localData[tbx+j].y-posq1.y, localData[tbx+j].z-posq1.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                    delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                    delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                    float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        float2 params2 = (float2) (localData[tbx+j].radius, localData[tbx+j].scaledRadius);\n"
"                        float rScaledRadiusJ = r+params2.y;\n"
"                        if ((j != tgx) && (params1.x < rScaledRadiusJ)) {\n"
"                            float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                            float u_ij = RECIP(rScaledRadiusJ);\n"
"                            float l_ij2 = l_ij*l_ij;\n"
"                            float u_ij2 = u_ij*u_ij;\n"
"                            float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                            bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                             (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                            if (params1.x < params2.y-r)\n"
"                                bornSum += 2.0f*(RECIP(params1.x)-l_ij);\n"
"                        }\n"
"                    }\n"
"                }\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                if (lasty != y) {\n"
"                    unsigned int j = y*TILE_SIZE + tgx;\n"
"                    float4 tempPosq = posq[j];\n"
"                    localData[get_local_id(0)].x = tempPosq.x;\n"
"                    localData[get_local_id(0)].y = tempPosq.y;\n"
"                    localData[get_local_id(0)].z = tempPosq.z;\n"
"                    localData[get_local_id(0)].q = tempPosq.w;\n"
"                    float2 tempParams = global_params[j];\n"
"                    localData[get_local_id(0)].radius = tempParams.x;\n"
"                    localData[get_local_id(0)].scaledRadius = tempParams.y;\n"
"                }\n"
"                localData[get_local_id(0)].bornSum = 0.0f;\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int flags = (numTiles <= maxTiles ? interactionFlags[pos] : 0xFFFFFFFF);\n"
"                bool computeSubset = false;\n"
"                if (flags != 0xFFFFFFFF) {\n"
"                    if (tgx < 2)\n"
"                        exclusionRange[2*localGroupIndex+tgx] = exclusionRowIndices[x+tgx];\n"
"                    if (tgx == 0)\n"
"                        exclusionIndex[localGroupIndex] = -1;\n"
"                    for (unsigned int i = exclusionRange[2*localGroupIndex]+tgx; i < exclusionRange[2*localGroupIndex+1]; i += TILE_SIZE)\n"
"                        if (exclusionIndices[i] == y)\n"
"                            exclusionIndex[localGroupIndex] = i*TILE_SIZE;\n"
"                    computeSubset = (exclusionIndex[localGroupIndex] == -1);\n"
"                }\n"
"                if (computeSubset) {\n"
"                    if (flags == 0) {\n"
"                        // No interactions in this tile.\n"
"                    }\n"
"                    else {\n"
"                        // Compute only a subset of the interactions in this tile.\n"
"\n"
"                        for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags&(1<<j)) != 0) {\n"
"                                float4 delta = (float4) (localData[tbx+j].x-posq1.x, localData[tbx+j].y-posq1.y, localData[tbx+j].z-posq1.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                                tempBuffer[get_local_id(0)] = 0.0f;\n"
"#ifdef USE_CUTOFF\n"
"                                if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                                if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"#endif\n"
"                                    float invR = RSQRT(r2);\n"
"                                    float r = RECIP(invR);\n"
"                                    float2 params2 = (float2) (localData[tbx+j].radius, localData[tbx+j].scaledRadius);\n"
"                                    float rScaledRadiusJ = r+params2.y;\n"
"                                    if (params1.x < rScaledRadiusJ) {\n"
"                                        float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                                        float u_ij = RECIP(rScaledRadiusJ);\n"
"                                        float l_ij2 = l_ij*l_ij;\n"
"                                        float u_ij2 = u_ij*u_ij;\n"
"                                        float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                        bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                         (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                                        if (params1.x < params2.y-r)\n"
"                                            bornSum += 2.0f*(RECIP(params1.x)-l_ij);\n"
"                                    }\n"
"                                    float rScaledRadiusI = r+params1.y;\n"
"                                    if (params2.x < rScaledRadiusI) {\n"
"                                        float l_ij = RECIP(max(params2.x, fabs(r-params1.y)));\n"
"                                        float u_ij = RECIP(rScaledRadiusI);\n"
"                                        float l_ij2 = l_ij*l_ij;\n"
"                                        float u_ij2 = u_ij*u_ij;\n"
"                                        float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                        float term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                         (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                                        if (params2.x < params1.y-r)\n"
"                                            term += 2.0f*(RECIP(params2.x)-l_ij);\n"
"                                        tempBuffer[get_local_id(0)] = term;\n"
"                                    }\n"
"                                }\n"
"\n"
"                                // Sum the forces on atom j.\n"
"\n"
"                                if (tgx % 4 == 0)\n"
"                                    tempBuffer[get_local_id(0)] += tempBuffer[get_local_id(0)+1]+tempBuffer[get_local_id(0)+2]+tempBuffer[get_local_id(0)+3];\n"
"                                if (tgx == 0)\n"
"                                    localData[tbx+j].bornSum += tempBuffer[get_local_id(0)]+tempBuffer[get_local_id(0)+4]+tempBuffer[get_local_id(0)+8]+tempBuffer[get_local_id(0)+12]+tempBuffer[get_local_id(0)+16]+tempBuffer[get_local_id(0)+20]+tempBuffer[get_local_id(0)+24]+tempBuffer[get_local_id(0)+28];\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"                else\n"
"#endif\n"
"                {\n"
"                    // Compute the full set of interactions in this tile.\n"
"\n"
"                    unsigned int tj = tgx;\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        float4 delta = (float4) (localData[tbx+tj].x-posq1.x, localData[tbx+tj].y-posq1.y, localData[tbx+tj].z-posq1.z, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                        float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                        if (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"                        if (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS) {\n"
"#endif\n"
"                            float invR = RSQRT(r2);\n"
"                            float r = RECIP(invR);\n"
"                            float2 params2 = (float2) (localData[tbx+tj].radius, localData[tbx+tj].scaledRadius);\n"
"                            float rScaledRadiusJ = r+params2.y;\n"
"                            if (params1.x < rScaledRadiusJ) {\n"
"                                float l_ij = RECIP(max(params1.x, fabs(r-params2.y)));\n"
"                                float u_ij = RECIP(rScaledRadiusJ);\n"
"                                float l_ij2 = l_ij*l_ij;\n"
"                                float u_ij2 = u_ij*u_ij;\n"
"                                float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                bornSum += l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                 (params2.y*params2.y*invR)*(l_ij2-u_ij2));\n"
"                                if (params1.x < params2.y-r)\n"
"                                    bornSum += 2.0f*(RECIP(params1.x)-l_ij);\n"
"                            }\n"
"                            float rScaledRadiusI = r+params1.y;\n"
"                            if (params2.x < rScaledRadiusI) {\n"
"                                float l_ij = RECIP(max(params2.x, fabs(r-params1.y)));\n"
"                                float u_ij = RECIP(rScaledRadiusI);\n"
"                                float l_ij2 = l_ij*l_ij;\n"
"                                float u_ij2 = u_ij*u_ij;\n"
"                                float ratio = LOG(u_ij * RECIP(l_ij));\n"
"                                float term = l_ij - u_ij + (0.50f*invR*ratio) + 0.25f*(r*(u_ij2-l_ij2) +\n"
"                                                 (params1.y*params1.y*invR)*(l_ij2-u_ij2));\n"
"                                if (params2.x < params1.y-r)\n"
"                                    term += 2.0f*(RECIP(params2.x)-l_ij);\n"
"                                localData[tbx+tj].bornSum += term;\n"
"                            }\n"
"                        }\n"
"                        tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // Write results.  We need to coordinate between warps to make sure no two of them\n"
"        // ever try to write to the same piece of memory at the same time.\n"
"        \n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        if (pos < end) {\n"
"            const unsigned int offset = x*TILE_SIZE + tgx;\n"
"            atom_add(&global_bornSum[offset], (long) (bornSum*0xFFFFFFFF));\n"
"        }\n"
"        if (pos < end && x != y) {\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&global_bornSum[offset], (long) (localData[get_local_id(0)].bornSum*0xFFFFFFFF));\n"
"        }\n"
"#else\n"
"        int writeX = (pos < end ? x : -1);\n"
"        int writeY = (pos < end && x != y ? y : -1);\n"
"        if (tgx == 0)\n"
"            reservedBlocks[localGroupIndex] = (int2)(writeX, writeY);\n"
"        bool done = false;\n"
"        int doneIndex = 0;\n"
"        int checkIndex = 0;\n"
"        while (true) {\n"
"            // See if any warp still needs to write its data.\n"
"\n"
"            bool allDone = true;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            while (doneIndex < WARPS_PER_GROUP && allDone) {\n"
"                if (reservedBlocks[doneIndex].x != -1)\n"
"                    allDone = false;\n"
"                else\n"
"                    doneIndex++;\n"
"            }\n"
"            if (allDone)\n"
"                break;\n"
"            if (!done) {\n"
"                // See whether this warp can write its data.  This requires that no previous warp\n"
"                // is trying to write to the same block of the buffer.\n"
"\n"
"                bool canWrite = (writeX != -1);\n"
"                while (checkIndex < localGroupIndex && canWrite) {\n"
"                    if ((reservedBlocks[checkIndex].x == x || reservedBlocks[checkIndex].y == x) ||\n"
"                            (writeY != -1 && (reservedBlocks[checkIndex].x == y || reservedBlocks[checkIndex].y == y)))\n"
"                        canWrite = false;\n"
"                    else\n"
"                        checkIndex++;\n"
"                }\n"
"                if (canWrite) {\n"
"                    // Write the data to global memory, then mark this warp as done.\n"
"\n"
"                    if (writeX > -1) {\n"
"                        const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        global_bornSum[offset] += bornSum;\n"
"                    }\n"
"                    if (writeY > -1) {\n"
"                        const unsigned int offset = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        global_bornSum[offset] += localData[get_local_id(0)].bornSum;\n"
"                    }\n"
"                    done = true;\n"
"                    if (tgx == 0)\n"
"                        reservedBlocks[localGroupIndex] = (int2)(-1, -1);\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"        lasty = y;\n"
"        pos++;\n"
"    } while (pos < end);\n"
"}\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float fx, fy, fz, fw;\n"
"    float bornRadius;\n"
"} AtomData2;\n"
"\n"
"/**\n"
" * First part of computing the GBSA interaction.\n"
" */\n"
"\n"
"__kernel void computeGBSAForce1(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers, __global long* restrict global_bornForce,\n"
"#else\n"
"        __global float4* restrict forceBuffers, __global float* restrict global_bornForce,\n"
"#endif\n"
"        __global float* restrict energyBuffer, __global const float4* restrict posq, __global const float* restrict global_bornRadii,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags,\n"
"#else\n"
"        unsigned int numTiles,\n"
"#endif\n"
"        __global unsigned int* exclusionIndices, __global unsigned int* exclusionRowIndices) {\n"
"    unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = warp*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"    unsigned int end = (warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"#else\n"
"    unsigned int pos = warp*numTiles/totalWarps;\n"
"    unsigned int end = (warp+1)*numTiles/totalWarps;\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData2 localData[FORCE_WORK_GROUP_SIZE];\n"
"    __local float4 tempBuffer[FORCE_WORK_GROUP_SIZE];\n"
"    __local int2 reservedBlocks[WARPS_PER_GROUP];\n"
"    __local unsigned int* exclusionRange = (__local unsigned int*) reservedBlocks;\n"
"    __local int exclusionIndex[WARPS_PER_GROUP];\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        const unsigned int tbx = get_local_id(0) - tgx;\n"
"        const unsigned int localGroupIndex = get_local_id(0)/TILE_SIZE;\n"
"        unsigned int x, y;\n"
"        float4 force = 0.0f;\n"
"        if (pos < end) {\n"
"#ifdef USE_CUTOFF\n"
"            if (numTiles <= maxTiles) {\n"
"                ushort2 tileIndices = tiles[pos];\n"
"                x = tileIndices.x;\n"
"                y = tileIndices.y;\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                    y += (x < y ? -1 : 1);\n"
"                    x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                }\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            float4 posq1 = posq[atom1];\n"
"            float bornRadius1 = global_bornRadii[atom1];\n"
"            if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                localData[get_local_id(0)].x = posq1.x;\n"
"                localData[get_local_id(0)].y = posq1.y;\n"
"                localData[get_local_id(0)].z = posq1.z;\n"
"                localData[get_local_id(0)].q = posq1.w;\n"
"                localData[get_local_id(0)].bornRadius = bornRadius1;\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    if (atom1 < NUM_ATOMS && y*TILE_SIZE+j < NUM_ATOMS) {\n"
"                        float4 posq2 = (float4) (localData[tbx+j].x, localData[tbx+j].y, localData[tbx+j].z, localData[tbx+j].q);\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                        float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        float bornRadius2 = localData[tbx+j].bornRadius;\n"
"                        float alpha2_ij = bornRadius1*bornRadius2;\n"
"                        float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                        float expTerm = EXP(-D_ij);\n"
"                        float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                        float denominator = SQRT(denominator2);\n"
"                        float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                        float Gpol = tempEnergy*RECIP(denominator2);\n"
"                        float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                        float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                        force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"                        energy += 0.5f*tempEnergy;\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"                    }\n"
"                }\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                if (lasty != y) {\n"
"                    unsigned int j = y*TILE_SIZE + tgx;\n"
"                    float4 tempPosq = posq[j];\n"
"                    localData[get_local_id(0)].x = tempPosq.x;\n"
"                    localData[get_local_id(0)].y = tempPosq.y;\n"
"                    localData[get_local_id(0)].z = tempPosq.z;\n"
"                    localData[get_local_id(0)].q = tempPosq.w;\n"
"                    localData[get_local_id(0)].bornRadius = global_bornRadii[j];\n"
"                }\n"
"                localData[get_local_id(0)].fx = 0.0f;\n"
"                localData[get_local_id(0)].fy = 0.0f;\n"
"                localData[get_local_id(0)].fz = 0.0f;\n"
"                localData[get_local_id(0)].fw = 0.0f;\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int flags = (numTiles <= maxTiles ? interactionFlags[pos] : 0xFFFFFFFF);\n"
"                bool computeSubset = false;\n"
"#ifdef USE_APPLE_WORKAROUND\n"
"                computeSubset = (flags == 0); // Workaround for a compiler bug in Apple's OpenCL on Lion\n"
"#else\n"
"                if (flags != 0xFFFFFFFF) {\n"
"                    if (tgx < 2)\n"
"                        exclusionRange[2*localGroupIndex+tgx] = exclusionRowIndices[x+tgx];\n"
"                    if (tgx == 0)\n"
"                        exclusionIndex[localGroupIndex] = -1;\n"
"                    for (unsigned int i = exclusionRange[2*localGroupIndex]+tgx; i < exclusionRange[2*localGroupIndex+1]; i += TILE_SIZE)\n"
"                        if (exclusionIndices[i] == y)\n"
"                            exclusionIndex[localGroupIndex] = i*TILE_SIZE;\n"
"                    computeSubset = (exclusionIndex[localGroupIndex] == -1);\n"
"                }\n"
"#endif\n"
"                if (computeSubset) {\n"
"                    if (flags == 0) {\n"
"                        // No interactions in this tile.\n"
"                    }\n"
"                    else {\n"
"                        // Compute only a subset of the interactions in this tile.\n"
"\n"
"                        for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags&(1<<j)) != 0) {\n"
"                                float4 posq2 = (float4) (localData[tbx+j].x, localData[tbx+j].y, localData[tbx+j].z, localData[tbx+j].q);\n"
"                                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                                float invR = RSQRT(r2);\n"
"                                float r = RECIP(invR);\n"
"                                float bornRadius2 = localData[tbx+j].bornRadius;\n"
"                                float alpha2_ij = bornRadius1*bornRadius2;\n"
"                                float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                                float expTerm = EXP(-D_ij);\n"
"                                float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                                float denominator = SQRT(denominator2);\n"
"                                float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                                float Gpol = tempEnergy*RECIP(denominator2);\n"
"                                float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                                float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"#ifdef USE_CUTOFF\n"
"                                if (atom1 >= NUM_ATOMS || y*TILE_SIZE+j >= NUM_ATOMS || r2 > CUTOFF_SQUARED) {\n"
"#else\n"
"                                if (atom1 >= NUM_ATOMS || y*TILE_SIZE+j >= NUM_ATOMS) {\n"
"#endif\n"
"                                    dEdR = 0.0f;\n"
"                                    dGpol_dalpha2_ij = 0.0f;\n"
"                                    tempEnergy = 0.0f;\n"
"                                }\n"
"                                energy += tempEnergy;\n"
"                                force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"                                delta.xyz *= dEdR;\n"
"                                force.xyz -= delta.xyz;\n"
"                                tempBuffer[get_local_id(0)] = (float4) (delta.xyz, dGpol_dalpha2_ij*bornRadius1);\n"
"#ifdef USE_CUTOFF\n"
"                                }\n"
"                                else\n"
"                                    tempBuffer[get_local_id(0)] = (float4) 0.0f;\n"
"#endif\n"
"\n"
"                                // Sum the forces on atom j.\n"
"\n"
"                                if (tgx % 4 == 0)\n"
"                                    tempBuffer[get_local_id(0)] += tempBuffer[get_local_id(0)+1]+tempBuffer[get_local_id(0)+2]+tempBuffer[get_local_id(0)+3];\n"
"                                if (tgx == 0) {\n"
"                                    float4 sum = tempBuffer[get_local_id(0)]+tempBuffer[get_local_id(0)+4]+tempBuffer[get_local_id(0)+8]+tempBuffer[get_local_id(0)+12]+tempBuffer[get_local_id(0)+16]+tempBuffer[get_local_id(0)+20]+tempBuffer[get_local_id(0)+24]+tempBuffer[get_local_id(0)+28];\n"
"                                    localData[tbx+j].fx += sum.x;\n"
"                                    localData[tbx+j].fy += sum.y;\n"
"                                    localData[tbx+j].fz += sum.z;\n"
"                                    localData[tbx+j].fw += sum.w;\n"
"                                }\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"                else\n"
"#endif\n"
"                {\n"
"                    // Compute the full set of interactions in this tile.\n"
"\n"
"                    unsigned int tj = tgx;\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        if (atom1 < NUM_ATOMS && y*TILE_SIZE+tj < NUM_ATOMS) {\n"
"                            float4 posq2 = (float4) (localData[tbx+tj].x, localData[tbx+tj].y, localData[tbx+tj].z, localData[tbx+tj].q);\n"
"                            float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                            delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                            delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                            delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                            float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                            if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                            float invR = RSQRT(r2);\n"
"                            float r = RECIP(invR);\n"
"                            float bornRadius2 = localData[tbx+tj].bornRadius;\n"
"                            float alpha2_ij = bornRadius1*bornRadius2;\n"
"                            float D_ij = r2*RECIP(4.0f*alpha2_ij);\n"
"                            float expTerm = EXP(-D_ij);\n"
"                            float denominator2 = r2 + alpha2_ij*expTerm;\n"
"                            float denominator = SQRT(denominator2);\n"
"                            float tempEnergy = (PREFACTOR*posq1.w*posq2.w)*RECIP(denominator);\n"
"                            float Gpol = tempEnergy*RECIP(denominator2);\n"
"                            float dGpol_dalpha2_ij = -0.5f*Gpol*expTerm*(1.0f+D_ij);\n"
"                            float dEdR = Gpol*(1.0f - 0.25f*expTerm);\n"
"                            force.w += dGpol_dalpha2_ij*bornRadius2;\n"
"                            energy += tempEnergy;\n"
"                            delta.xyz *= dEdR;\n"
"                            force.xyz -= delta.xyz;\n"
"                            localData[tbx+tj].fx += delta.x;\n"
"                            localData[tbx+tj].fy += delta.y;\n"
"                            localData[tbx+tj].fz += delta.z;\n"
"                            localData[tbx+tj].fw += dGpol_dalpha2_ij*bornRadius1;\n"
"#ifdef USE_CUTOFF\n"
"                            }\n"
"#endif\n"
"                        }\n"
"                        tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // Write results.  We need to coordinate between warps to make sure no two of them\n"
"        // ever try to write to the same piece of memory at the same time.\n"
"        \n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        if (pos < end) {\n"
"            const unsigned int offset = x*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (force.x*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (force.y*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (force.z*0xFFFFFFFF));\n"
"            atom_add(&global_bornForce[offset], (long) (force.w*0xFFFFFFFF));\n"
"        }\n"
"        if (pos < end && x != y) {\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (localData[get_local_id(0)].fx*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fy*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fz*0xFFFFFFFF));\n"
"            atom_add(&global_bornForce[offset], (long) (localData[get_local_id(0)].fw*0xFFFFFFFF));\n"
"        }\n"
"#else\n"
"        int writeX = (pos < end ? x : -1);\n"
"        int writeY = (pos < end && x != y ? y : -1);\n"
"        if (tgx == 0)\n"
"            reservedBlocks[localGroupIndex] = (int2)(writeX, writeY);\n"
"        bool done = false;\n"
"        int doneIndex = 0;\n"
"        int checkIndex = 0;\n"
"        while (true) {\n"
"            // See if any warp still needs to write its data.\n"
"\n"
"            bool allDone = true;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            while (doneIndex < WARPS_PER_GROUP && allDone) {\n"
"                if (reservedBlocks[doneIndex].x != -1)\n"
"                    allDone = false;\n"
"                else\n"
"                    doneIndex++;\n"
"            }\n"
"            if (allDone)\n"
"                break;\n"
"            if (!done) {\n"
"                // See whether this warp can write its data.  This requires that no previous warp\n"
"                // is trying to write to the same block of the buffer.\n"
"\n"
"                bool canWrite = (writeX != -1);\n"
"                while (checkIndex < localGroupIndex && canWrite) {\n"
"                    if ((reservedBlocks[checkIndex].x == x || reservedBlocks[checkIndex].y == x) ||\n"
"                            (writeY != -1 && (reservedBlocks[checkIndex].x == y || reservedBlocks[checkIndex].y == y)))\n"
"                        canWrite = false;\n"
"                    else\n"
"                        checkIndex++;\n"
"                }\n"
"                if (canWrite) {\n"
"                    // Write the data to global memory, then mark this warp as done.\n"
"\n"
"                    if (writeX > -1) {\n"
"                        const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset].xyz += force.xyz;\n"
"                        global_bornForce[offset] += force.w;\n"
"                    }\n"
"                    if (writeY > -1) {\n"
"                        const unsigned int offset = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset] += (float4) (localData[get_local_id(0)].fx, localData[get_local_id(0)].fy, localData[get_local_id(0)].fz, 0.0f);\n"
"                        global_bornForce[offset] += localData[get_local_id(0)].fw;\n"
"                    }\n"
"                    done = true;\n"
"                    if (tgx == 0)\n"
"                        reservedBlocks[localGroupIndex] = (int2)(-1, -1);\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"        lasty = y;\n"
"        pos++;\n"
"    } while (pos < end);\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::combinedfields = "/**\n"
" * kernel: MeasureCombinedFields\n"
" * this kernel file implements all the kernels called by the above mentioned class inside \n"
" * OpenCLKernels.cpp\n"
" * it calculated total velocity and mass,\n"
" * total momentum\n"
" * KE\n"
" * DOF\n"
" * totalMolecules\n"
" */\n"
"\n"
"//- kernel calculatetotalmass\n"
"// it calculates total mass and velocity\n"
"\n"
"__kernel void measureCombinedFields(int numAtoms,\n"
"					__global const float4* restrict velm,\n"
"					__global float4* restrict totalKe,\n"
"					__local volatile float4* restrict localKe\n"
"				)\n"
"{\n"
"	unsigned int gid = get_global_id(0);\n"
"	float4 ke = (float4) 0.0f;\n"
"	while(gid<numAtoms)\n"
"	{\n"
"		float4 velocity = velm[gid];\n"
"		float sqr = ((velocity.x*velocity.x)+(velocity.y*velocity.y)+(velocity.z*velocity.z));\n"
"		ke.x += 0.5 * sqr / velocity.w;\n"
"		ke.y += 1.0;\n"
"		ke.z = 0.0f;\n"
"		ke.w = 0.0f;\n"
"		gid += get_global_size(0);\n"
"	}\n"
"	\n"
"	unsigned int tid = get_local_id(0);\n"
"	localKe[tid] = ke;\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if(tid<32){\n"
"		localKe[tid] += localKe[tid+32];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<16){\n"
"		localKe[tid] += localKe[tid+16];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<8){\n"
"		localKe[tid] += localKe[tid+8];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<4){\n"
"		localKe[tid] += localKe[tid+4];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	if(tid<2){\n"
"		localKe[tid] += localKe[tid+2];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if(tid==0){\n"
"		totalKe[get_group_id(0)] = localKe[tid] + localKe[tid+1];\n"
"	}\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"";
const string OpenCLKernelSources::removeCM = "/**\n"
" * Calculate the center of mass momentum.\n"
" */\n"
"\n"
"__kernel void calcCenterOfMassMomentum(int numAtoms, __global const float4* restrict velm, __global float4* restrict cmMomentum, __local volatile float4* restrict temp) {\n"
"    int index = get_global_id(0);\n"
"    float4 cm = 0.0f;\n"
"    while (index < numAtoms) {\n"
"        float4 velocity = velm[index];\n"
"        if (velocity.w != 0.0)\n"
"            cm.xyz += velocity.xyz/velocity.w;\n"
"        index += get_global_size(0);\n"
"    }\n"
"\n"
"    // Sum the threads in this group.\n"
"\n"
"    int thread = get_local_id(0);\n"
"    temp[thread] = cm;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef WARPS_ARE_ATOMIC\n"
"    if (thread < 32) {\n"
"        temp[thread] += temp[thread+32];\n"
"        if (thread < 16)\n"
"            temp[thread] += temp[thread+16];\n"
"        if (thread < 8)\n"
"            temp[thread] += temp[thread+8];\n"
"        if (thread < 4)\n"
"            temp[thread] += temp[thread+4];\n"
"        if (thread < 2)\n"
"            temp[thread] += temp[thread+2];\n"
"    }\n"
"#else\n"
"    if (thread < 32)\n"
"        temp[thread] += temp[thread+32];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 16)\n"
"        temp[thread] += temp[thread+16];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 8)\n"
"        temp[thread] += temp[thread+8];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 4)\n"
"        temp[thread] += temp[thread+4];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 2)\n"
"        temp[thread] += temp[thread+2];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"    if (thread == 0)\n"
"        cmMomentum[get_group_id(0)] = temp[thread]+temp[thread+1];\n"
"}\n"
"\n"
"/**\n"
" * Remove center of mass motion.\n"
" */\n"
"\n"
"__kernel void removeCenterOfMassMomentum(unsigned int numAtoms, __global float4* restrict velm, __global const float4* restrict cmMomentum, __local volatile float4* restrict temp) {\n"
"    // First sum all of the momenta that were calculated by individual groups.\n"
"\n"
"    unsigned int index = get_local_id(0);\n"
"    float4 cm = 0.0f;\n"
"    while (index < get_num_groups(0)) {\n"
"        cm += cmMomentum[index];\n"
"        index += get_local_size(0);\n"
"    }\n"
"    int thread = get_local_id(0);\n"
"    temp[thread] = cm;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef WARPS_ARE_ATOMIC\n"
"    if (thread < 32) {\n"
"        temp[thread] += temp[thread+32];\n"
"        if (thread < 16)\n"
"            temp[thread] += temp[thread+16];\n"
"        if (thread < 8)\n"
"            temp[thread] += temp[thread+8];\n"
"        if (thread < 4)\n"
"            temp[thread] += temp[thread+4];\n"
"        if (thread < 2)\n"
"            temp[thread] += temp[thread+2];\n"
"    }\n"
"#else\n"
"    if (thread < 32)\n"
"        temp[thread] += temp[thread+32];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 16)\n"
"        temp[thread] += temp[thread+16];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 8)\n"
"        temp[thread] += temp[thread+8];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 4)\n"
"        temp[thread] += temp[thread+4];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 2)\n"
"        temp[thread] += temp[thread+2];\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    cm = (temp[0]+temp[1])*INVERSE_TOTAL_MASS;\n"
"\n"
"    // Now remove the center of mass velocity from each atom.\n"
"\n"
"    index = get_global_id(0);\n"
"    while (index < numAtoms) {\n"
"        velm[index].xyz -= cm.xyz;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customGBEnergyN2_nvidia = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#define STORE_DERIVATIVE_1(INDEX) atom_add(&derivBuffers[offset+(INDEX-1)*PADDED_NUM_ATOMS], (long) (deriv##INDEX##_1*0xFFFFFFFF));\n"
"#define STORE_DERIVATIVE_2(INDEX) atom_add(&derivBuffers[offset+(INDEX-1)*PADDED_NUM_ATOMS], (long) (local_deriv##INDEX[get_local_id(0)]*0xFFFFFFFF));\n"
"#else\n"
"#define STORE_DERIVATIVE_1(INDEX) derivBuffers##INDEX[offset] += deriv##INDEX##_1;\n"
"#define STORE_DERIVATIVE_2(INDEX) derivBuffers##INDEX[offset] += local_deriv##INDEX[get_local_id(0)];\n"
"#endif\n"
"#define TILE_SIZE 32\n"
"\n"
"/**\n"
" * Compute a force based on pair interactions.\n"
" */\n"
"__kernel void computeN2Energy(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global float4* restrict forceBuffers,\n"
"#endif\n"
"        __global float* restrict energyBuffer, __local float4* restrict local_force,\n"
"	__global const float4* restrict posq, __local float4* restrict local_posq, __global const unsigned int* restrict exclusions, __global const unsigned int* restrict exclusionIndices,\n"
"        __global const unsigned int* restrict exclusionRowIndices, __local float4* restrict tempBuffer,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = warp*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"    unsigned int end = (warp+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/totalWarps;\n"
"#else\n"
"    unsigned int pos = warp*numTiles/totalWarps;\n"
"    unsigned int end = (warp+1)*numTiles/totalWarps;\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local unsigned int exclusionRange[2*WARPS_PER_GROUP];\n"
"    __local int exclusionIndex[WARPS_PER_GROUP];\n"
"    __local int2* reservedBlocks = (__local int2*) exclusionRange;\n"
"    \n"
"    do {\n"
"        // Extract the coordinates of this tile\n"
"        const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        const unsigned int tbx = get_local_id(0) - tgx;\n"
"        const unsigned int localGroupIndex = get_local_id(0)/TILE_SIZE;\n"
"        unsigned int x, y;\n"
"        float4 force = 0.0f;\n"
"        DECLARE_ATOM1_DERIVATIVES\n"
"        if (pos < end) {\n"
"#ifdef USE_CUTOFF\n"
"            if (numTiles <= maxTiles) {\n"
"                ushort2 tileIndices = tiles[pos];\n"
"                x = tileIndices.x;\n"
"                y = tileIndices.y;\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                    y += (x < y ? -1 : 1);\n"
"                    x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"                }\n"
"            }\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"            float4 posq1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"\n"
"            // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"            if (tgx < 2)\n"
"                exclusionRange[2*localGroupIndex+tgx] = exclusionRowIndices[x+tgx];\n"
"            if (tgx == 0)\n"
"                exclusionIndex[localGroupIndex] = -1;\n"
"            for (unsigned int i = exclusionRange[2*localGroupIndex]+tgx; i < exclusionRange[2*localGroupIndex+1]; i += TILE_SIZE)\n"
"                if (exclusionIndices[i] == y)\n"
"                    exclusionIndex[localGroupIndex] = i*TILE_SIZE;\n"
"            bool hasExclusions = (exclusionIndex[localGroupIndex] > -1);\n"
"#else\n"
"            bool hasExclusions = false;\n"
"#endif\n"
"            if (pos >= end)\n"
"                ; // This warp is done.\n"
"            else if (x == y) {\n"
"                // This tile is on the diagonal.\n"
"\n"
"                const unsigned int localAtomIndex = get_local_id(0);\n"
"                local_posq[localAtomIndex] = posq1;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_1\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[exclusionIndex[localGroupIndex]+tgx];\n"
"#endif\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    int atom2 = tbx+j;\n"
"                    float4 posq2 = local_posq[atom2];\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                    delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                    delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                    float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    float invR = RSQRT(r2);\n"
"                    float r = RECIP(invR);\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    float dEdR = 0.0f;\n"
"                    float tempEnergy = 0.0f;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"                        COMPUTE_INTERACTION\n"
"                        dEdR /= -r;\n"
"                    }\n"
"                    energy += 0.5f*tempEnergy;\n"
"                    delta.xyz *= dEdR;\n"
"                    force.xyz -= delta.xyz;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else {\n"
"                // This is an off-diagonal tile.\n"
"\n"
"                const unsigned int localAtomIndex = get_local_id(0);\n"
"                if (lasty != y) {\n"
"                    unsigned int j = y*TILE_SIZE + tgx;\n"
"                    local_posq[localAtomIndex] = posq[j];\n"
"                    LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                }\n"
"                local_force[localAtomIndex] = 0.0f;\n"
"                CLEAR_LOCAL_DERIVATIVES\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int flags = (numTiles <= maxTiles ? interactionFlags[pos] : 0xFFFFFFFF);\n"
"                if (!hasExclusions && flags == 0) {\n"
"                    // No interactions in this tile.\n"
"                }\n"
"                else\n"
"#endif\n"
"                {\n"
"                    // Compute the full set of interactions in this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"                    unsigned int excl = (hasExclusions ? exclusions[exclusionIndex[localGroupIndex]+tgx] : 0xFFFFFFFF);\n"
"                    excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"                    unsigned int tj = tgx;\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        int atom2 = tbx+tj;\n"
"                        float4 posq2 = local_posq[atom2];\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                        float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+tj;\n"
"                        float dEdR = 0.0f;\n"
"                        float tempEnergy = 0.0f;\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                        }\n"
"                        energy += tempEnergy;\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        atom2 = tbx+tj;\n"
"                        local_force[atom2].xyz += delta.xyz;\n"
"                        RECORD_DERIVATIVE_2\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        excl >>= 1;\n"
"#endif\n"
"                        tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        \n"
"        // Write results.  We need to coordinate between warps to make sure no two of them\n"
"        // ever try to write to the same piece of memory at the same time.\n"
"        \n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        if (pos < end) {\n"
"            const unsigned int offset = x*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (force.x*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (force.y*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (force.z*0xFFFFFFFF));\n"
"            STORE_DERIVATIVES_1\n"
"        }\n"
"        if (pos < end && x != y) {\n"
"            const unsigned int offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (local_force[get_local_id(0)].x*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (local_force[get_local_id(0)].y*0xFFFFFFFF));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (local_force[get_local_id(0)].z*0xFFFFFFFF));\n"
"            STORE_DERIVATIVES_2\n"
"        }\n"
"#else\n"
"        int writeX = (pos < end ? x : -1);\n"
"        int writeY = (pos < end && x != y ? y : -1);\n"
"        if (tgx == 0)\n"
"            reservedBlocks[localGroupIndex] = (int2)(writeX, writeY);\n"
"        bool done = false;\n"
"        int doneIndex = 0;\n"
"        int checkIndex = 0;\n"
"        while (true) {\n"
"            // See if any warp still needs to write its data.\n"
"\n"
"            bool allDone = true;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            while (doneIndex < WARPS_PER_GROUP && allDone) {\n"
"                if (reservedBlocks[doneIndex].x != -1)\n"
"                    allDone = false;\n"
"                else\n"
"                    doneIndex++;\n"
"            }\n"
"            if (allDone)\n"
"                break;\n"
"            if (!done) {\n"
"                // See whether this warp can write its data.  This requires that no previous warp\n"
"                // is trying to write to the same block of the buffer.\n"
"\n"
"                bool canWrite = (writeX != -1);\n"
"                while (checkIndex < localGroupIndex && canWrite) {\n"
"                    if ((reservedBlocks[checkIndex].x == x || reservedBlocks[checkIndex].y == x) ||\n"
"                            (writeY != -1 && (reservedBlocks[checkIndex].x == y || reservedBlocks[checkIndex].y == y)))\n"
"                        canWrite = false;\n"
"                    else\n"
"                        checkIndex++;\n"
"                }\n"
"                if (canWrite) {\n"
"                    // Write the data to global memory, then mark this warp as done.\n"
"\n"
"                    if (writeX > -1) {\n"
"                        const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset].xyz += force.xyz;\n"
"                        STORE_DERIVATIVES_1\n"
"                    }\n"
"                    if (writeY > -1) {\n"
"                        const unsigned int offset = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        forceBuffers[offset].xyz += local_force[get_local_id(0)].xyz;\n"
"                        STORE_DERIVATIVES_2\n"
"                    }\n"
"                    done = true;\n"
"                    if (tgx == 0)\n"
"                        reservedBlocks[localGroupIndex] = (int2)(-1, -1);\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"        pos++;\n"
"    } while (pos < end);\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::fft = "float2 multiplyComplex(float2 c1, float2 c2) {\n"
"    return (float2) (c1.x*c2.x-c1.y*c2.y, c1.x*c2.y+c1.y*c2.x);\n"
"}\n"
"\n"
"/**\n"
" * Perform a 1D FFT on each row along one axis.\n"
" */\n"
"\n"
"__kernel void execFFT(__global const float2* restrict in, __global float2* restrict out, float sign, __local float2* restrict w,\n"
"        __local float2* restrict data0, __local float2* restrict data1) {\n"
"    for (int i = get_local_id(0); i < ZSIZE; i += get_local_size(0))\n"
"        w[i] = (float2) (cos(-sign*i*2*M_PI/ZSIZE), sin(-sign*i*2*M_PI/ZSIZE));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int index = get_group_id(0); index < XSIZE*YSIZE; index += get_num_groups(0)) {\n"
"        int x = index/YSIZE;\n"
"        int y = index-x*YSIZE;\n"
"#if LOOP_REQUIRED\n"
"        for (int z = get_local_id(0); z < ZSIZE; z += get_local_size(0))\n"
"            data0[z] = in[x*(YSIZE*ZSIZE)+y*ZSIZE+z];\n"
"#else\n"
"        data0[get_local_id(0)] = in[x*(YSIZE*ZSIZE)+y*ZSIZE+get_local_id(0)];\n"
"#endif\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        COMPUTE_FFT\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::virtualSites = "/**\n"
" * Compute the positions of virtual sites\n"
" */\n"
"__kernel void computeVirtualSites(__global float4* restrict posq, __global const int4* restrict avg2Atoms, __global const float2* restrict avg2Weights,\n"
"        __global const int4* restrict avg3Atoms, __global const float4* restrict avg3Weights,\n"
"        __global const int4* restrict outOfPlaneAtoms, __global const float4* restrict outOfPlaneWeights) {\n"
"    \n"
"    // Two particle average sites.\n"
"    \n"
"    for (int index = get_global_id(0); index < NUM_2_AVERAGE; index += get_global_size(0)) {\n"
"        int4 atoms = avg2Atoms[index];\n"
"        float2 weights = avg2Weights[index];\n"
"        float4 pos = posq[atoms.x];\n"
"        float4 pos1 = posq[atoms.y];\n"
"        float4 pos2 = posq[atoms.z];\n"
"        pos.xyz = pos1.xyz*weights.x + pos2.xyz*weights.y;\n"
"        posq[atoms.x] = pos;\n"
"    }\n"
"    \n"
"    // Three particle average sites.\n"
"    \n"
"    for (int index = get_global_id(0); index < NUM_3_AVERAGE; index += get_global_size(0)) {\n"
"        int4 atoms = avg3Atoms[index];\n"
"        float4 weights = avg3Weights[index];\n"
"        float4 pos = posq[atoms.x];\n"
"        float4 pos1 = posq[atoms.y];\n"
"        float4 pos2 = posq[atoms.z];\n"
"        float4 pos3 = posq[atoms.w];\n"
"        pos.xyz = pos1.xyz*weights.x + pos2.xyz*weights.y + pos3.xyz*weights.z;\n"
"        posq[atoms.x] = pos;\n"
"    }\n"
"    \n"
"    // Out of plane sites.\n"
"    \n"
"    for (int index = get_global_id(0); index < NUM_OUT_OF_PLANE; index += get_global_size(0)) {\n"
"        int4 atoms = outOfPlaneAtoms[index];\n"
"        float4 weights = outOfPlaneWeights[index];\n"
"        float4 pos = posq[atoms.x];\n"
"        float4 pos1 = posq[atoms.y];\n"
"        float4 pos2 = posq[atoms.z];\n"
"        float4 pos3 = posq[atoms.w];\n"
"        float4 v12 = pos2-pos1;\n"
"        float4 v13 = pos3-pos1;\n"
"        pos.xyz = pos1.xyz + v12.xyz*weights.x + v13.xyz*weights.y + cross(v12, v13).xyz*weights.z;\n"
"        posq[atoms.x] = pos;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Distribute forces from virtual sites to the atoms they are based on.\n"
" */\n"
"__kernel void distributeForces(__global const float4* restrict posq, __global float4* restrict force,\n"
"        __global const int4* restrict avg2Atoms, __global const float2* restrict avg2Weights,\n"
"        __global const int4* restrict avg3Atoms, __global const float4* restrict avg3Weights,\n"
"        __global const int4* restrict outOfPlaneAtoms, __global const float4* restrict outOfPlaneWeights) {\n"
"    \n"
"    // Two particle average sites.\n"
"    \n"
"    for (int index = get_global_id(0); index < NUM_2_AVERAGE; index += get_global_size(0)) {\n"
"        int4 atoms = avg2Atoms[index];\n"
"        float2 weights = avg2Weights[index];\n"
"        float4 f = force[atoms.x];\n"
"        float4 f1 = force[atoms.y];\n"
"        float4 f2 = force[atoms.z];\n"
"        f1.xyz += f.xyz*weights.x;\n"
"        f2.xyz += f.xyz*weights.y;\n"
"        force[atoms.y] = f1;\n"
"        force[atoms.z] = f2;\n"
"    }\n"
"    \n"
"    // Three particle average sites.\n"
"    \n"
"    for (int index = get_global_id(0); index < NUM_3_AVERAGE; index += get_global_size(0)) {\n"
"        int4 atoms = avg3Atoms[index];\n"
"        float4 weights = avg3Weights[index];\n"
"        float4 f = force[atoms.x];\n"
"        float4 f1 = force[atoms.y];\n"
"        float4 f2 = force[atoms.z];\n"
"        float4 f3 = force[atoms.w];\n"
"        f1.xyz += f.xyz*weights.x;\n"
"        f2.xyz += f.xyz*weights.y;\n"
"        f3.xyz += f.xyz*weights.z;\n"
"        force[atoms.y] = f1;\n"
"        force[atoms.z] = f2;\n"
"        force[atoms.w] = f3;\n"
"    }\n"
"    \n"
"    // Out of plane sites.\n"
"    \n"
"    for (int index = get_global_id(0); index < NUM_OUT_OF_PLANE; index += get_global_size(0)) {\n"
"        int4 atoms = outOfPlaneAtoms[index];\n"
"        float4 weights = outOfPlaneWeights[index];\n"
"        float4 pos1 = posq[atoms.y];\n"
"        float4 pos2 = posq[atoms.z];\n"
"        float4 pos3 = posq[atoms.w];\n"
"        float4 v12 = pos2-pos1;\n"
"        float4 v13 = pos3-pos1;\n"
"        float4 f = force[atoms.x];\n"
"        float4 f1 = force[atoms.y];\n"
"        float4 f2 = force[atoms.z];\n"
"        float4 f3 = force[atoms.w];\n"
"        float4 fp2 = (float4) (weights.x*f.x - weights.z*v13.z*f.y + weights.z*v13.y*f.z,\n"
"                   weights.z*v13.z*f.x + weights.x*f.y - weights.z*v13.x*f.z,\n"
"                  -weights.z*v13.y*f.x + weights.z*v13.x*f.y + weights.x*f.z, 0.0f);\n"
"        float4 fp3 = (float4) (weights.y*f.x + weights.z*v12.z*f.y - weights.z*v12.y*f.z,\n"
"                  -weights.z*v12.z*f.x + weights.y*f.y + weights.z*v12.x*f.z,\n"
"                   weights.z*v12.y*f.x - weights.z*v12.x*f.y + weights.y*f.z, 0.0f);\n"
"        f1.xyz += f.xyz-fp2.xyz-fp3.xyz;\n"
"        f2.xyz += fp2.xyz;\n"
"        f3.xyz += fp3.xyz;\n"
"        force[atoms.y] = f1;\n"
"        force[atoms.z] = f2;\n"
"        force[atoms.w] = f3;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::sort = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"\n"
"KEY_TYPE getValue(DATA_TYPE value) {\n"
"    return SORT_KEY;\n"
"}\n"
"\n"
"/**\n"
" * Calculate the minimum and maximum value in the array to be sorted.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"__kernel void computeRange(__global const DATA_TYPE* restrict data, uint length, __global KEY_TYPE* restrict range, __local KEY_TYPE* restrict buffer) {\n"
"    KEY_TYPE minimum = MAX_KEY;\n"
"    KEY_TYPE maximum = MIN_KEY;\n"
"\n"
"    // Each thread calculates the range of a subset of values.\n"
"\n"
"    for (uint index = get_local_id(0); index < length; index += get_local_size(0)) {\n"
"        KEY_TYPE value = getValue(data[index]);\n"
"        minimum = min(minimum, value);\n"
"        maximum = max(maximum, value);\n"
"    }\n"
"\n"
"    // Now reduce them.\n"
"\n"
"    buffer[get_local_id(0)] = minimum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"        if (get_local_id(0)+step < get_local_size(0) && get_local_id(0)%(2*step) == 0)\n"
"            buffer[get_local_id(0)] = min(buffer[get_local_id(0)], buffer[get_local_id(0)+step]);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    minimum = buffer[0];\n"
"    buffer[get_local_id(0)] = maximum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"        if (get_local_id(0)+step < get_local_size(0) && get_local_id(0)%(2*step) == 0)\n"
"            buffer[get_local_id(0)] = max(buffer[get_local_id(0)], buffer[get_local_id(0)+step]);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    maximum = buffer[0];\n"
"    if (get_local_id(0) == 0) {\n"
"        range[0] = minimum;\n"
"        range[1] = maximum;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Assign elements to buckets.\n"
" */\n"
"__kernel void assignElementsToBuckets(__global const DATA_TYPE* restrict data, uint length, uint numBuckets, __global const KEY_TYPE* restrict range,\n"
"        __global uint* bucketOffset, __global uint* restrict bucketOfElement, __global uint* restrict offsetInBucket) {\n"
"#ifdef AMD_ATOMIC_WORK_AROUND\n"
"    // Do a byte write to force all memory accesses to interactionCount to use the complete path.\n"
"    // This avoids the atomic access from causing all word accesses to other buffers from using the slow complete path.\n"
"    // The IF actually causes the write to never be executed, its presence is all that is needed.\n"
"    // AMD APP SDK 2.4 has this problem.\n"
"    if (get_global_id(0) == get_local_id(0)+1)\n"
"        ((__global char*)bucketOffset)[sizeof(int)*numBuckets+1] = 0;\n"
"#endif\n"
"    float minValue = (float) (range[0]);\n"
"    float maxValue = (float) (range[1]);\n"
"    float bucketWidth = (maxValue-minValue)/numBuckets;\n"
"    for (uint index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"#if defined(MAC_AMD_WORKAROUND) && VALUE_IS_INT2\n"
"        __global int* d = (__global int*) data;\n"
"        int2 element = (int2) (d[2*index], d[2*index+1]);\n"
"        float key = (float) getValue(element);\n"
"#else\n"
"        float key = (float) getValue(data[index]);\n"
"#endif\n"
"        uint bucketIndex = min((uint) ((key-minValue)/bucketWidth), numBuckets-1);\n"
"        offsetInBucket[index] = atom_inc(&bucketOffset[bucketIndex]);\n"
"        bucketOfElement[index] = bucketIndex;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the bucket sizes to compute the start position of each bucket.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"__kernel void computeBucketPositions(uint numBuckets, __global uint* restrict bucketOffset, __local uint* restrict buffer) {\n"
"    uint globalOffset = 0;\n"
"    for (uint startBucket = 0; startBucket < numBuckets; startBucket += get_local_size(0)) {\n"
"        // Load the bucket sizes into local memory.\n"
"\n"
"        uint globalIndex = startBucket+get_local_id(0);\n"
"        buffer[get_local_id(0)] = (globalIndex < numBuckets ? bucketOffset[globalIndex] : 0);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Perform a parallel prefix sum.\n"
"\n"
"        for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"            uint add = (get_local_id(0) >= step ? buffer[get_local_id(0)-step] : 0);\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            buffer[get_local_id(0)] += add;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"\n"
"        // Write the results back to global memory.\n"
"\n"
"        if (globalIndex < numBuckets)\n"
"            bucketOffset[globalIndex] = buffer[get_local_id(0)]+globalOffset;\n"
"        globalOffset += buffer[get_local_size(0)-1];\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy the input data into the buckets for sorting.\n"
" */\n"
"__kernel void copyDataToBuckets(__global const DATA_TYPE* restrict data, __global DATA_TYPE* restrict buckets, uint length, __global const uint* restrict bucketOffset, __global const uint* restrict bucketOfElement, __global const uint* restrict offsetInBucket) {\n"
"    for (uint index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"        DATA_TYPE element = data[index];\n"
"        uint bucketIndex = bucketOfElement[index];\n"
"        uint offset = (bucketIndex == 0 ? 0 : bucketOffset[bucketIndex-1]);\n"
"        buckets[offset+offsetInBucket[index]] = element;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sort the data in each bucket.\n"
" */\n"
"__kernel void sortBuckets(__global DATA_TYPE* restrict data, __global const DATA_TYPE* restrict buckets, uint numBuckets, __global const uint* restrict bucketOffset, __local DATA_TYPE* restrict buffer) {\n"
"    for (uint index = get_group_id(0); index < numBuckets; index += get_num_groups(0)) {\n"
"        uint startIndex = (index == 0 ? 0 : bucketOffset[index-1]);\n"
"        uint endIndex = bucketOffset[index];\n"
"        uint length = endIndex-startIndex;\n"
"        if (length <= get_local_size(0)) {\n"
"            // Load the data into local memory.\n"
"\n"
"            if (get_local_id(0) < length)\n"
"                buffer[get_local_id(0)] = buckets[startIndex+get_local_id(0)];\n"
"            else\n"
"                buffer[get_local_id(0)] = MAX_VALUE;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Perform a bitonic sort in local memory.\n"
"\n"
"            for (uint k = 2; k <= get_local_size(0); k *= 2) {\n"
"                for (uint j = k/2; j > 0; j /= 2) {\n"
"                    int ixj = get_local_id(0)^j;\n"
"                    if (ixj > get_local_id(0)) {\n"
"                        DATA_TYPE value1 = buffer[get_local_id(0)];\n"
"                        DATA_TYPE value2 = buffer[ixj];\n"
"                        bool ascending = (get_local_id(0)&k) == 0;\n"
"                        KEY_TYPE lowKey = (ascending ? getValue(value1) : getValue(value2));\n"
"                        KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                        if (lowKey > highKey) {\n"
"                            buffer[get_local_id(0)] = value2;\n"
"                            buffer[ixj] = value1;\n"
"                        }\n"
"                    }\n"
"                    barrier(CLK_LOCAL_MEM_FENCE);\n"
"                }\n"
"            }\n"
"\n"
"            // Write the data to the sorted array.\n"
"\n"
"            if (get_local_id(0) < length)\n"
"                data[startIndex+get_local_id(0)] = buffer[get_local_id(0)];\n"
"        }\n"
"        else {\n"
"            // Copy the bucket data over to the output array.\n"
"\n"
"            for (uint i = get_local_id(0); i < length; i += get_local_size(0))\n"
"                data[startIndex+i] = buckets[startIndex+i];\n"
"            barrier(CLK_GLOBAL_MEM_FENCE);\n"
"\n"
"            // Perform a bitonic sort in global memory.\n"
"\n"
"            for (uint k = 2; k < 2*length; k *= 2) {\n"
"                for (uint j = k/2; j > 0; j /= 2) {\n"
"                    for (uint i = get_local_id(0); i < length; i += get_local_size(0)) {\n"
"                        int ixj = i^j;\n"
"                        if (ixj > i && ixj < length) {\n"
"                            DATA_TYPE value1 = data[startIndex+i];\n"
"                            DATA_TYPE value2 = data[startIndex+ixj];\n"
"                            bool ascending = ((i&k) == 0);\n"
"                            for (uint mask = k*2; mask < 2*length; mask *= 2)\n"
"                                ascending = ((i&mask) == 0 ? !ascending : ascending);\n"
"                            KEY_TYPE lowKey  = (ascending ? getValue(value1) : getValue(value2));\n"
"                            KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                            if (lowKey > highKey) {\n"
"                                data[startIndex+i] = value2;\n"
"                                data[startIndex+ixj] = value1;\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customGBChainRule = "#ifdef USE_CUTOFF\n"
"if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2 && r2 < CUTOFF_SQUARED) {\n"
"#else\n"
"if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"#ifdef USE_SYMMETRIC\n"
"    float tempForce = 0.0f;\n"
"#else\n"
"    float4 tempForce1 = (float4) 0.0f;\n"
"    float4 tempForce2 = (float4) 0.0f;\n"
"#endif\n"
"    COMPUTE_FORCE\n"
"#ifdef USE_SYMMETRIC\n"
"    dEdR += tempForce*invR;\n"
"#else\n"
"    dEdR1 += tempForce1;\n"
"    dEdR2 += tempForce2;\n"
"#endif\n"
"}\n"
"";
const string OpenCLKernelSources::customGBEnergyN2_default = "#define TILE_SIZE 32\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#define STORE_DERIVATIVE_1(INDEX) atom_add(&derivBuffers[offset1+(INDEX-1)*PADDED_NUM_ATOMS], (long) (deriv##INDEX##_1*0xFFFFFFFF));\n"
"#define STORE_DERIVATIVE_2(INDEX) atom_add(&derivBuffers[offset2+(INDEX-1)*PADDED_NUM_ATOMS], (long) (local_deriv##INDEX[get_local_id(0)]*0xFFFFFFFF));\n"
"#else\n"
"#define STORE_DERIVATIVE_1(INDEX) derivBuffers##INDEX[offset1] += deriv##INDEX##_1+tempDerivBuffer##INDEX[get_local_id(0)+TILE_SIZE];\n"
"#define STORE_DERIVATIVE_2(INDEX) derivBuffers##INDEX[offset2] += local_deriv##INDEX[get_local_id(0)]+local_deriv##INDEX[get_local_id(0)+TILE_SIZE];\n"
"#endif\n"
"\n"
"/**\n"
" * Compute a force based on pair interactions.\n"
" */\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(WORK_GROUP_SIZE, 1, 1)))\n"
"void computeN2Energy(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global float4* restrict forceBuffers,\n"
"#endif\n"
"        __global float* restrict energyBuffer, __local float4* restrict local_force,\n"
"	    __global const float4* restrict posq, __local float4* restrict local_posq, __global const unsigned int* restrict exclusions, __global const unsigned int* restrict exclusionIndices,\n"
"        __global const unsigned int* restrict exclusionRowIndices, __local float4* restrict tempForceBuffer,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local unsigned int exclusionRange[2];\n"
"    __local int exclusionIndex[1];\n"
"    DECLARE_TEMP_BUFFERS\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"        unsigned int baseLocalAtom = (get_local_id(0) < TILE_SIZE ? 0 : TILE_SIZE/2);\n"
"        unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        unsigned int forceBufferOffset = (tgx < TILE_SIZE/2 ? 0 : TILE_SIZE);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        float4 force = 0.0f;\n"
"        DECLARE_ATOM1_DERIVATIVES\n"
"        float4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"\n"
"        // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"        if (get_local_id(0) < 2)\n"
"            exclusionRange[get_local_id(0)] = exclusionRowIndices[x+get_local_id(0)];\n"
"        if (tgx == 0)\n"
"            exclusionIndex[0] = -1;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        for (int i = exclusionRange[0]+tgx; i < exclusionRange[1]; i += TILE_SIZE)\n"
"            if (exclusionIndices[i] == y)\n"
"                exclusionIndex[0] = i*TILE_SIZE;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        bool hasExclusions = (exclusionIndex[0] > -1);\n"
"#endif\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = get_local_id(0);\n"
"            local_posq[localAtomIndex] = posq1;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef USE_EXCLUSIONS\n"
"            unsigned int excl = exclusions[exclusionIndex[0]+tgx] >> baseLocalAtom;\n"
"#endif\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                int atom2 = baseLocalAtom+j;\n"
"                float4 posq2 = local_posq[atom2];\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+baseLocalAtom+j;\n"
"                float dEdR = 0.0f;\n"
"                float tempEnergy = 0.0f;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"                    COMPUTE_INTERACTION\n"
"                    dEdR /= -r;\n"
"                }\n"
"                energy += 0.5f*tempEnergy;\n"
"                delta.xyz *= dEdR;\n"
"                force.xyz -= delta.xyz;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE) {\n"
"                tempForceBuffer[get_local_id(0)] = force;\n"
"                SET_TEMP_BUFFERS\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset1], (long) ((force.x + tempForceBuffer[get_local_id(0)+TILE_SIZE].x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+PADDED_NUM_ATOMS], (long) ((force.y + tempForceBuffer[get_local_id(0)+TILE_SIZE].y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+2*PADDED_NUM_ATOMS], (long) ((force.z + tempForceBuffer[get_local_id(0)+TILE_SIZE].z)*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                forceBuffers[offset1].xyz += force.xyz + tempForceBuffer[get_local_id(0)+TILE_SIZE].xyz;\n"
"#endif\n"
"                STORE_DERIVATIVES_1\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            const unsigned int localAtomIndex = get_local_id(0);\n"
"            if (lasty != y && get_local_id(0) < TILE_SIZE) {\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                local_posq[localAtomIndex] = posq[j];\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"            local_force[localAtomIndex] = 0.0f;\n"
"            CLEAR_LOCAL_DERIVATIVES\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"            unsigned int excl = (hasExclusions ? exclusions[exclusionIndex[0]+tgx] : 0xFFFFFFFF);\n"
"            excl = (excl >> baseLocalAtom) & 0xFFFF;\n"
"            excl += excl << 16;\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"            unsigned int tj = tgx%(TILE_SIZE/2);\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                int atom2 = baseLocalAtom+tj;\n"
"                float4 posq2 = local_posq[atom2];\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+baseLocalAtom+tj;\n"
"                float dEdR = 0.0f;\n"
"                float tempEnergy = 0.0f;\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                    COMPUTE_INTERACTION\n"
"                    dEdR /= -r;\n"
"                }\n"
"                energy += tempEnergy;\n"
"                delta.xyz *= dEdR;\n"
"                force.xyz -= delta.xyz;\n"
"                atom2 = baseLocalAtom+tj+forceBufferOffset;\n"
"                local_force[baseLocalAtom+tj+forceBufferOffset].xyz += delta.xyz;\n"
"                RECORD_DERIVATIVE_2\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj+1)%(TILE_SIZE/2);\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE) {\n"
"                tempForceBuffer[get_local_id(0)] = force;\n"
"                SET_TEMP_BUFFERS\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset1], (long) ((force.x+tempForceBuffer[get_local_id(0)+TILE_SIZE].x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+PADDED_NUM_ATOMS], (long) ((force.y+tempForceBuffer[get_local_id(0)+TILE_SIZE].y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+2*PADDED_NUM_ATOMS], (long) ((force.z+tempForceBuffer[get_local_id(0)+TILE_SIZE].z)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2], (long) ((local_force[get_local_id(0)].x+local_force[get_local_id(0)+TILE_SIZE].x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2+PADDED_NUM_ATOMS], (long) ((local_force[get_local_id(0)].y+local_force[get_local_id(0)+TILE_SIZE].y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2+2*PADDED_NUM_ATOMS], (long) ((local_force[get_local_id(0)].z+local_force[get_local_id(0)+TILE_SIZE].z)*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + y*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                forceBuffers[offset1].xyz += force.xyz+tempForceBuffer[get_local_id(0)+TILE_SIZE].xyz;\n"
"                forceBuffers[offset2].xyz += local_force[get_local_id(0)].xyz+local_force[get_local_id(0)+TILE_SIZE].xyz;\n"
"#endif\n"
"                STORE_DERIVATIVES_1\n"
"                STORE_DERIVATIVES_2\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::customGBEnergyN2_cpu = "#define TILE_SIZE 32\n"
"#define STORE_DERIVATIVE_1(INDEX) derivBuffers##INDEX[offset1] += deriv##INDEX##_1;\n"
"#define STORE_DERIVATIVE_2(INDEX) derivBuffers##INDEX[offset2] += local_deriv##INDEX[tgx];\n"
"\n"
"/**\n"
" * Compute a force based on pair interactions.\n"
" */\n"
"\n"
"__kernel void computeN2Energy(__global float4* restrict forceBuffers, __global float* restrict energyBuffer, __local float4* restrict local_force,\n"
"	__global const float4* restrict posq, __local float4* restrict local_posq, __global const unsigned int* restrict exclusions, __global const unsigned int* restrict exclusionIndices,\n"
"        __global const unsigned int* restrict exclusionRowIndices, __local float4* restrict tempBuffer,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"\n"
"        // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int exclusionStart = exclusionRowIndices[x];\n"
"        unsigned int exclusionEnd = exclusionRowIndices[x+1];\n"
"        int exclusionIndex = -1;\n"
"        for (int i = exclusionStart; i < exclusionEnd; i++)\n"
"            if (exclusionIndices[i] == y) {\n"
"                exclusionIndex = i*TILE_SIZE;\n"
"                break;\n"
"            }\n"
"        bool hasExclusions = (exclusionIndex > -1);\n"
"#else\n"
"        bool hasExclusions = false;\n"
"#endif\n"
"\n"
"        // Load the data for this tile if we don't already have it cached.\n"
"\n"
"        if (lasty != y) {\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"                local_posq[localAtomIndex] = posq[j];\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"        }\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[exclusionIndex+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                float4 force = 0.0f;\n"
"                DECLARE_ATOM1_DERIVATIVES\n"
"                float4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                    float4 posq2 = local_posq[j];\n"
"                    float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                    delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                    float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                    float invR = RSQRT(r2);\n"
"                    float r = RECIP(invR);\n"
"                    unsigned int atom2 = j;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+j;\n"
"                    float dEdR = 0.0f;\n"
"                    float tempEnergy = 0.0f;\n"
"                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"                        COMPUTE_INTERACTION\n"
"                        dEdR /= -r;\n"
"                    }\n"
"                    energy += 0.5f*tempEnergy;\n"
"                    delta.xyz *= dEdR;\n"
"                    force.xyz -= delta.xyz;\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results\n"
"\n"
"                unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset1].xyz += force.xyz;\n"
"                STORE_DERIVATIVES_1\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"                local_force[localAtomIndex] = 0.0f;\n"
"                CLEAR_LOCAL_DERIVATIVES\n"
"            }\n"
"#if defined(USE_CUTOFF) && defined(USE_EXCLUSIONS)\n"
"            unsigned int flags1 = (numTiles <= maxTiles ? interactionFlags[2*pos] : 0xFFFFFFFF);\n"
"            unsigned int flags2 = (numTiles <= maxTiles ? interactionFlags[2*pos+1] : 0xFFFFFFFF);\n"
"            if (!hasExclusions && (flags1 != 0xFFFFFFFF || flags2 != 0xFFFFFFFF)) {\n"
"                // Compute only a subset of the interactions in this tile.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    if ((flags2&(1<<tgx)) != 0) {\n"
"                        unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                        float value = 0.0f;\n"
"                        DECLARE_ATOM1_DERIVATIVES\n"
"                        float4 posq1 = posq[atom1];\n"
"                        LOAD_ATOM1_PARAMETERS\n"
"                        for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                            if ((flags&(1<<j)) != 0) {\n"
"                                float4 posq2 = local_posq[j];\n"
"                                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                                delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                                float r2 = dot(delta.xyz, delta.xyz);\n"
"                                if (r2 < CUTOFF_SQUARED) {\n"
"                                    float invR = RSQRT(r2);\n"
"                                    float r = RECIP(invR);\n"
"                                    unsigned int atom2 = j;\n"
"                                    LOAD_ATOM2_PARAMETERS\n"
"                                    atom2 = y*TILE_SIZE+j;\n"
"                                    float dEdR = 0.0f;\n"
"                                    float tempEnergy = 0.0f;\n"
"                                    if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                                        COMPUTE_INTERACTION\n"
"                                        dEdR /= -r;\n"
"                                    }\n"
"                                    energy += tempEnergy;\n"
"                                    delta.xyz *= dEdR;\n"
"                                    force.xyz -= delta.xyz;\n"
"                                    atom2 = j;\n"
"                                    local_force[atom2].xyz += delta.xyz;\n"
"                                    RECORD_DERIVATIVE_2\n"
"                                }\n"
"                            }\n"
"                        }\n"
"\n"
"                        // Write results for atom1.\n"
"\n"
"                        unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                        global_value[offset] += value;\n"
"                    }\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // Compute the full set of interactions in this tile.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    float4 force = 0.0f;\n"
"                    DECLARE_ATOM1_DERIVATIVES\n"
"                    float4 posq1 = posq[atom1];\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"                    unsigned int excl = (hasExclusions ? exclusions[exclusionIndex+tgx] : 0xFFFFFFFF);\n"
"#endif\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                        float4 posq2 = local_posq[j];\n"
"                        float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                        delta.xyz -= floor(delta.xyz*invPeriodicBoxSize.xyz+0.5f)*periodicBoxSize.xyz;\n"
"#endif\n"
"                        float r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                        float invR = RSQRT(r2);\n"
"                        float r = RECIP(invR);\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"                        float dEdR = 0.0f;\n"
"                        float tempEnergy = 0.0f;\n"
"                        if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"                            COMPUTE_INTERACTION\n"
"                            dEdR /= -r;\n"
"                        }\n"
"                        energy += tempEnergy;\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        atom2 = j;\n"
"                        local_force[atom2].xyz += delta.xyz;\n"
"                        RECORD_DERIVATIVE_2\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        excl >>= 1;\n"
"#endif\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"                    unsigned int offset1 = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset1].xyz += force.xyz;\n"
"                    STORE_DERIVATIVES_1\n"
"                }\n"
"            }\n"
"\n"
"            // Write results\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int offset2 = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset2].xyz += local_force[tgx].xyz;\n"
"                STORE_DERIVATIVES_2\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::andersenThermostat = "/**\n"
" * Apply the Andersen thermostat to adjust particle velocities.\n"
" */\n"
"\n"
"__kernel void applyAndersenThermostat(float collisionFrequency, float kT, __global float4* velm, __global const float2* restrict stepSize, __global const float4* restrict random,\n"
"        unsigned int randomIndex, __global const int* restrict atomGroups) {\n"
"    float collisionProbability = 1.0f-exp(-collisionFrequency*stepSize[0].y);\n"
"    float randomRange = erf(collisionProbability/sqrt(2.0f));\n"
"    for (int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        float4 velocity = velm[index];\n"
"        float4 selectRand = random[randomIndex+atomGroups[index]];\n"
"        float4 velRand = random[randomIndex+index];\n"
"        float scale = (selectRand.w > -randomRange && selectRand.w < randomRange ? 0.0f : 1.0f);\n"
"        float add = (1.0f-scale)*sqrt(kT*velocity.w);\n"
"        velocity.xyz = scale*velocity.xyz + add*velRand.xyz;\n"
"        velm[index] = velocity;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customGBValueN2_default = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define TILE_SIZE 32\n"
"\n"
"/**\n"
" * Compute a value based on pair interactions.\n"
" */\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(WORK_GROUP_SIZE, 1, 1)))\n"
"void computeN2Value(__global const float4* restrict posq, __local float4* restrict local_posq, __global const unsigned int* restrict exclusions,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict global_value,\n"
"#else\n"
"        __global float* restrict global_value,\n"
"#endif\n"
"        __local float* restrict local_value,\n"
"        __local float* restrict tempBuffer,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = get_group_id(0)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*(numTiles > maxTiles ? NUM_BLOCKS*(NUM_BLOCKS+1)/2 : numTiles)/get_num_groups(0);\n"
"#else\n"
"    unsigned int pos = get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = (get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local unsigned int exclusionRange[2];\n"
"    __local int exclusionIndex[1];\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"        unsigned int baseLocalAtom = (get_local_id(0) < TILE_SIZE ? 0 : TILE_SIZE/2);\n"
"        unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        unsigned int valueBufferOffset = (tgx < TILE_SIZE/2 ? 0 : TILE_SIZE);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        float value = 0.0f;\n"
"        float4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"\n"
"        // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"        if (get_local_id(0) < 2)\n"
"            exclusionRange[get_local_id(0)] = exclusionRowIndices[x+get_local_id(0)];\n"
"        if (tgx == 0)\n"
"            exclusionIndex[0] = -1;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        for (int i = exclusionRange[0]+tgx; i < exclusionRange[1]; i += TILE_SIZE)\n"
"            if (exclusionIndices[i] == y)\n"
"                exclusionIndex[0] = i*TILE_SIZE;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        bool hasExclusions = (exclusionIndex[0] > -1);\n"
"#endif\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = get_local_id(0);\n"
"            local_posq[localAtomIndex] = posq1;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef USE_EXCLUSIONS\n"
"            unsigned int excl = exclusions[exclusionIndex[0]+tgx] >> baseLocalAtom;\n"
"#endif\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                int atom2 = baseLocalAtom+j;\n"
"                float4 posq2 = local_posq[atom2];\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+baseLocalAtom+j;\n"
"                float tempValue1 = 0.0f;\n"
"                float tempValue2 = 0.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                if (!isExcluded && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#else\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS && atom1 != atom2) {\n"
"#endif\n"
"                    COMPUTE_VALUE\n"
"                }\n"
"                value += tempValue1;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"            }\n"
"\n"
"            // Sum the values and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE)\n"
"                tempBuffer[get_local_id(0)] = value;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset = x*TILE_SIZE + tgx;\n"
"                atom_add(&global_value[offset], (long) ((value + tempBuffer[get_local_id(0)+TILE_SIZE])*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset = x*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                global_value[offset] += value + tempBuffer[get_local_id(0)+TILE_SIZE];\n"
"#endif\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            if (lasty != y && get_local_id(0) < TILE_SIZE) {\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                local_posq[get_local_id(0)] = posq[j];\n"
"                const unsigned int localAtomIndex = get_local_id(0);\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"            local_value[get_local_id(0)] = 0.0f;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"            unsigned int excl = (hasExclusions ? exclusions[exclusionIndex[0]+tgx] : 0xFFFFFFFF);\n"
"            excl = (excl >> baseLocalAtom) & 0xFFFF;\n"
"            excl += excl << 16;\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"            unsigned int tj = tgx%(TILE_SIZE/2);\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                int atom2 = baseLocalAtom+tj;\n"
"                float4 posq2 = local_posq[atom2];\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef USE_CUTOFF\n"
"                if (r2 < CUTOFF_SQUARED) {\n"
"#endif\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+baseLocalAtom+tj;\n"
"                float tempValue1 = 0.0f;\n"
"                float tempValue2 = 0.0f;\n"
"#ifdef USE_EXCLUSIONS\n"
"                if (!isExcluded && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#else\n"
"                if (atom1 < NUM_ATOMS && atom2 < NUM_ATOMS) {\n"
"#endif\n"
"                    COMPUTE_VALUE\n"
"                }\n"
"                value += tempValue1;\n"
"                local_value[baseLocalAtom+tj+valueBufferOffset] += tempValue2;\n"
"#ifdef USE_CUTOFF\n"
"                }\n"
"#endif\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj+1)%(TILE_SIZE/2);\n"
"            }\n"
"\n"
"            // Sum the values and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE)\n"
"                tempBuffer[get_local_id(0)] = value;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"                atom_add(&global_value[offset1], (long) ((value + tempBuffer[get_local_id(0)+TILE_SIZE])*0xFFFFFFFF));\n"
"                atom_add(&global_value[offset2], (long) ((local_value[get_local_id(0)] + local_value[get_local_id(0)+TILE_SIZE])*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + y*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                global_value[offset1] += value + tempBuffer[get_local_id(0)+TILE_SIZE];\n"
"                global_value[offset2] += local_value[get_local_id(0)] + local_value[get_local_id(0)+TILE_SIZE];\n"
"#endif\n"
"            }\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::velocityverlet = "#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"\n"
"/**\n"
" * Perform the first step of velocity verlet integration.\n"
" */\n"
"\n"
"\n"
"__kernel void velocityVerletPart1(int numAtoms, \n"
"				   __global const float* deltaT,\n"
"				   __global float4* restrict posq,\n"
"				   __global float4* restrict velm,\n"
"				   __global const float4* restrict forces\n"
"                  ) {\n"
"    \n"
"    float dtPos = deltaT[0];\n"
"    float dtVel = 0.5*dtPos;\n"
"    unsigned int idx = get_global_id(0);\n"
"    if(idx < numAtoms)\n"
"    {\n"
"        //store the velocity locally\n"
"        float4 velocity = velm[idx];\n"
"		float4 accel = (float4) (0.0);\n"
"		float4 pos = posq[idx];\n"
"        if(velocity.w != 0.0)\n"
"        {\n"
"            accel.xyz = forces[idx].xyz*velocity.w;\n"
"            accel.xyz = accel.xyz * dtVel;\n"
"            velocity.xyz += accel.xyz;\n"
"            accel.xyz = velocity.xyz * dtPos;\n"
"	  		pos = pos + accel;\n"
"            velm[idx] = velocity;\n"
"            posq[idx] = pos;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Perform the second step of velocity verlet integration.\n"
" */\n"
"\n"
"__kernel void velocityVerletPart2(int numAtoms, \n"
"				   __global const float* deltaT,\n"
"				   __global float4* restrict velm,\n"
"				   __global const float4* restrict forces\n"
"				  ) {\n"
"    float dtVel = 0.5*deltaT[0];\n"
"    unsigned int idx = get_global_id(0);\n"
"    if(idx < numAtoms)\n"
"    {\n"
"	  //store the velocity locally\n"
"	  float4 velocity = velm[idx];\n"
"	  float4 accel = (float4) (0.0);\n"
"	  if(velocity.w != 0.0)\n"
"	  {\n"
"          accel.xyz = forces[idx].xyz*velocity.w;\n"
"          accel.xyz = accel.xyz * dtVel;\n"
"          velocity.xyz += accel.xyz;\n"
"          velm[idx] = velocity;\n"
"	  }\n"
"    \n"
"    }//end if\n"
"}\n"
"\n"
"__kernel void binForces(int numAtoms,\n"
"	__global float4* restrict forces\n"
"	)\n"
"{\n"
"	unsigned int idx = get_global_id(0);\n"
"	float x = (0.0001*4.87288629354e-12)/1.6605e-12;\n"
"	float4 binforces = (float4) (x,0.0f,0.0f,0.0f);\n"
"	if(idx<numAtoms)\n"
"	{\n"
"		forces[idx].xyz += binforces.xyz;\n"
"	}\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded_default = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"#define TILE_SIZE 32\n"
"\n"
"// Cannot use float3 as OpenCL defines it to be 4 DWORD aligned. This would\n"
"// cause every element of array to have DWORD of padding to make it 4 DWORD\n"
"// aligned which wastes space and causes LDS bank conflicts as stride is no\n"
"// longer odd DWORDS.\n"
"typedef struct {\n"
"    float x, y, z;\n"
"} UnalignedFloat3;\n"
"\n"
"typedef struct {\n"
"    float x, y, z;\n"
"    float q;\n"
"    float fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"#ifndef PARAMETER_SIZE_IS_EVEN\n"
"    float padding;\n"
"#endif\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(FORCE_WORK_GROUP_SIZE, 1, 1)))\n"
"void computeNonbonded(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global float4* restrict forceBuffers,\n"
"#endif\n"
"        __global float* restrict energyBuffer, __global const float4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices,\n"
"        unsigned int startTileIndex, unsigned int endTileIndex,\n"
"#ifdef USE_CUTOFF\n"
"        __global const ushort2* restrict tiles, __global const unsigned int* restrict interactionCount, float4 periodicBoxSize, float4 invPeriodicBoxSize, unsigned int maxTiles, __global const unsigned int* restrict interactionFlags\n"
"#else\n"
"        unsigned int numTiles\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = (numTiles > maxTiles ? startTileIndex+get_group_id(0)*(endTileIndex-startTileIndex)/get_num_groups(0) : get_group_id(0)*numTiles/get_num_groups(0));\n"
"    unsigned int end = (numTiles > maxTiles ? startTileIndex+(get_group_id(0)+1)*(endTileIndex-startTileIndex)/get_num_groups(0) : (get_group_id(0)+1)*numTiles/get_num_groups(0));\n"
"#else\n"
"    unsigned int pos = startTileIndex+get_group_id(0)*numTiles/get_num_groups(0);\n"
"    unsigned int end = startTileIndex+(get_group_id(0)+1)*numTiles/get_num_groups(0);\n"
"#endif\n"
"    float energy = 0.0f;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    __local AtomData localData[TILE_SIZE];\n"
"    __local UnalignedFloat3 localForce[FORCE_WORK_GROUP_SIZE];\n"
"#ifdef USE_EXCLUSIONS\n"
"    __local unsigned int exclusionRange[2];\n"
"    __local int exclusionIndex[1];\n"
"#endif\n"
"\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        unsigned int x, y;\n"
"#ifdef USE_CUTOFF\n"
"        if (numTiles <= maxTiles) {\n"
"            ushort2 tileIndices = tiles[pos];\n"
"            x = tileIndices.x;\n"
"            y = tileIndices.y;\n"
"        }\n"
"        else\n"
"#endif\n"
"        {\n"
"            y = (unsigned int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"        }\n"
"        unsigned int baseLocalAtom = (get_local_id(0) < TILE_SIZE ? 0 : TILE_SIZE/2);\n"
"        unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"        unsigned int localForceOffset = get_local_id(0) & ~(TILE_SIZE-1);\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        float4 force = 0.0f;\n"
"        float4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"\n"
"        // Locate the exclusion data for this tile.\n"
"\n"
"#ifdef USE_EXCLUSIONS\n"
"        if (get_local_id(0) < 2)\n"
"            exclusionRange[get_local_id(0)] = exclusionRowIndices[x+get_local_id(0)];\n"
"        if (get_local_id(0) == 0)\n"
"            exclusionIndex[0] = -1;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        for (int i = exclusionRange[0]+get_local_id(0); i < exclusionRange[1]; i += FORCE_WORK_GROUP_SIZE)\n"
"            if (exclusionIndices[i] == y)\n"
"                exclusionIndex[0] = i*TILE_SIZE;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        bool hasExclusions = (exclusionIndex[0] > -1);\n"
"#endif\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"                const unsigned int localAtomIndex = tgx;\n"
"                localData[localAtomIndex].x = posq1.x;\n"
"                localData[localAtomIndex].y = posq1.y;\n"
"                localData[localAtomIndex].z = posq1.z;\n"
"                localData[localAtomIndex].q = posq1.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef USE_EXCLUSIONS\n"
"            unsigned int excl = exclusions[exclusionIndex[0]+tgx] >> baseLocalAtom;\n"
"#endif\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                unsigned int atom2 = baseLocalAtom+j;\n"
"                float4 posq2 = (float4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+baseLocalAtom+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                float dEdR = 0.0f;\n"
"#else\n"
"                float4 dEdR1 = (float4) 0.0f;\n"
"                float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                float tempEnergy = 0.0f;\n"
"                COMPUTE_INTERACTION\n"
"                energy += 0.5f*tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"                excl >>= 1;\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE) {\n"
"                localData[tgx].fx = force.x;\n"
"                localData[tgx].fy = force.y;\n"
"                localData[tgx].fz = force.z;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset = x*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset], (long) ((force.x + localData[tgx].fx)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) ((force.y + localData[tgx].fy)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) ((force.z + localData[tgx].fz)*0xFFFFFFFF));\n"
"#else\n"
"                force.x += localData[tgx].fx;\n"
"                force.y += localData[tgx].fy;\n"
"                force.z += localData[tgx].fz;\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                unsigned int offset = x*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                unsigned int offset = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                // Cheaper to load/store float4 than float3.\n"
"                float4 sum = forceBuffers[offset];\n"
"                sum.xyz += force.xyz;\n"
"                forceBuffers[offset] = sum;\n"
"#endif\n"
"            }\n"
"            // barrier not required here as localData[*].temp is not accessed before encountering another barrier.\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            if (lasty != y && get_local_id(0) < TILE_SIZE) {\n"
"                const unsigned int localAtomIndex = tgx;\n"
"                unsigned int j = y*TILE_SIZE + tgx;\n"
"                float4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            }\n"
"            localForce[get_local_id(0)].x = 0.0f;\n"
"            localForce[get_local_id(0)].y = 0.0f;\n"
"            localForce[get_local_id(0)].z = 0.0f;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Compute the full set of interactions in this tile.\n"
"\n"
"            unsigned int tj = (tgx+baseLocalAtom) & (TILE_SIZE-1);\n"
"#ifdef USE_EXCLUSIONS\n"
"            unsigned int excl = (hasExclusions ? exclusions[exclusionIndex[0]+tgx] : 0xFFFFFFFF);\n"
"            excl = (excl >> tj) | (excl << (TILE_SIZE - tj));\n"
"#endif\n"
"            for (unsigned int j = 0; j < TILE_SIZE/2; j++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = !(excl & 0x1);\n"
"#endif\n"
"                float4 posq2 = (float4) (localData[tj].x, localData[tj].y, localData[tj].z, localData[tj].q);\n"
"                float4 delta = (float4) (posq2.xyz - posq1.xyz, 0.0f);\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"                float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                float invR = RSQRT(r2);\n"
"                float r = RECIP(invR);\n"
"                int atom2 = tj;\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+tj;\n"
"#ifdef USE_SYMMETRIC\n"
"                float dEdR = 0.0f;\n"
"#else\n"
"                float4 dEdR1 = (float4) 0.0f;\n"
"                float4 dEdR2 = (float4) 0.0f;\n"
"#endif\n"
"                float tempEnergy = 0.0f;\n"
"                COMPUTE_INTERACTION\n"
"                energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                delta.xyz *= dEdR;\n"
"                force.xyz -= delta.xyz;\n"
"                localForce[tj+localForceOffset].x += delta.x;\n"
"                localForce[tj+localForceOffset].y += delta.y;\n"
"                localForce[tj+localForceOffset].z += delta.z;\n"
"#else\n"
"                force.xyz -= dEdR1.xyz;\n"
"                localForce[tj+localForceOffset].x += dEdR2.x;\n"
"                localForce[tj+localForceOffset].y += dEdR2.y;\n"
"                localForce[tj+localForceOffset].z += dEdR2.z;\n"
"#endif\n"
"                barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj+1) & (TILE_SIZE-1);\n"
"            }\n"
"\n"
"            // Sum the forces and write results.\n"
"\n"
"            if (get_local_id(0) >= TILE_SIZE) {\n"
"                localData[tgx].fx = force.x;\n"
"                localData[tgx].fy = force.y;\n"
"                localData[tgx].fz = force.z;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) < TILE_SIZE) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset1], (long) ((force.x + localData[tgx].fx)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+PADDED_NUM_ATOMS], (long) ((force.y + localData[tgx].fy)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset1+2*PADDED_NUM_ATOMS], (long) ((force.z + localData[tgx].fz)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2], (long) ((localForce[tgx].x + localForce[tgx+TILE_SIZE].x)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2+PADDED_NUM_ATOMS], (long) ((localForce[tgx].y + localForce[tgx+TILE_SIZE].y)*0xFFFFFFFF));\n"
"                atom_add(&forceBuffers[offset2+2*PADDED_NUM_ATOMS], (long) ((localForce[tgx].z + localForce[tgx+TILE_SIZE].z)*0xFFFFFFFF));\n"
"#else\n"
"#ifdef USE_OUTPUT_BUFFER_PER_BLOCK\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + y*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + x*PADDED_NUM_ATOMS;\n"
"#else\n"
"                const unsigned int offset1 = x*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                const unsigned int offset2 = y*TILE_SIZE + tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"#endif\n"
"                // Cheaper to load/store float4 than float3. Do all loads before all stores to minimize store-load waits.\n"
"                float4 sum1 = forceBuffers[offset1];\n"
"                float4 sum2 = forceBuffers[offset2];\n"
"                sum1.x += localData[tgx].fx + force.x;\n"
"                sum1.y += localData[tgx].fy + force.y;\n"
"                sum1.z += localData[tgx].fz + force.z;\n"
"                sum2.x += localForce[tgx].x + localForce[tgx+TILE_SIZE].x;\n"
"                sum2.y += localForce[tgx].y + localForce[tgx+TILE_SIZE].y;\n"
"                sum2.z += localForce[tgx].z + localForce[tgx+TILE_SIZE].z;\n"
"                forceBuffers[offset1] = sum1;\n"
"                forceBuffers[offset2] = sum2;\n"
"#endif\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"        lasty = y;\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"";
const string OpenCLKernelSources::constraints = "__kernel void applyPositionDeltas(__global float4* restrict posq, __global float4* restrict posDelta) {\n"
"    for (unsigned int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"        float4 position = posq[index];\n"
"        position.xyz += posDelta[index].xyz;\n"
"        posq[index] = position;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::nonbondedExceptions = "float4 exceptionParams = PARAMS[index];\n"
"float4 delta = pos2-pos1;\n"
"float r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"float invR = RSQRT(r2);\n"
"float sig2 = invR*exceptionParams.y;\n"
"sig2 *= sig2;\n"
"float sig6 = sig2*sig2*sig2;\n"
"float dEdR = exceptionParams.z*(12.0f*sig6-6.0f)*sig6;\n"
"float tempEnergy = exceptionParams.z*(sig6-1.0f)*sig6;\n"
"dEdR += exceptionParams.x*invR;\n"
"dEdR *= invR*invR;\n"
"tempEnergy += exceptionParams.x*invR;\n"
"energy += tempEnergy;\n"
"delta.xyz *= dEdR;\n"
"float4 force1 = -delta;\n"
"float4 force2 = delta;\n"
"";
const string OpenCLKernelSources::gbsaObcReductions = "#define DIELECTRIC_OFFSET 0.009f\n"
"#define PROBE_RADIUS 0.14f\n"
"#define SURFACE_AREA_FACTOR -170.351730667551f //-6.0f*3.14159265358979323846f*0.0216f*1000.0f*0.4184f;\n"
"\n"
"/**\n"
" * Reduce the Born sums to compute the Born radii.\n"
" */\n"
"\n"
"__kernel void reduceBornSum(int bufferSize, int numBuffers, float alpha, float beta, float gamma,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            __global const long* restrict bornSum,\n"
"#else\n"
"            __global const float* restrict bornSum,\n"
"#endif\n"
"            __global const float2* restrict params, __global float* restrict bornRadii, __global float* restrict obcChain) {\n"
"    unsigned int index = get_global_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        // Get summed Born data\n"
"\n"
"        int totalSize = bufferSize*numBuffers;\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        float sum = (1.0f/0xFFFFFFFF)*bornSum[index];\n"
"#else\n"
"        float sum = bornSum[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += bornSum[i];\n"
"#endif\n"
"\n"
"        // Now calculate Born radius and OBC term.\n"
"\n"
"        float offsetRadius = params[index].x;\n"
"        sum *= 0.5f*offsetRadius;\n"
"        float sum2 = sum*sum;\n"
"        float sum3 = sum*sum2;\n"
"        float tanhSum = tanh(alpha*sum - beta*sum2 + gamma*sum3);\n"
"        float nonOffsetRadius = offsetRadius + DIELECTRIC_OFFSET;\n"
"        float radius = 1.0f/(1.0f/offsetRadius - tanhSum/nonOffsetRadius);\n"
"        float chain = offsetRadius*(alpha - 2.0f*beta*sum + 3.0f*gamma*sum2);\n"
"        chain = (1.0f-tanhSum*tanhSum)*chain / nonOffsetRadius;\n"
"        bornRadii[index] = radius;\n"
"        obcChain[index] = chain;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Reduce the Born force.\n"
" */\n"
"\n"
"__kernel void reduceBornForce(int bufferSize, int numBuffers, __global float* bornForce,\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            __global const long* restrict bornForceIn,\n"
"#endif\n"
"            __global float* restrict energyBuffer, __global const float2* restrict params, __global const float* restrict bornRadii, __global const float* restrict obcChain) {\n"
"    float energy = 0.0f;\n"
"    unsigned int index = get_global_id(0);\n"
"    while (index < NUM_ATOMS) {\n"
"        // Sum the Born force\n"
"\n"
"        int totalSize = bufferSize*numBuffers;\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        float force = (1.0f/0xFFFFFFFF)*bornForceIn[index];\n"
"#else\n"
"        float force = bornForce[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            force += bornForce[i];\n"
"#endif\n"
"        // Now calculate the actual force\n"
"\n"
"        float offsetRadius = params[index].x;\n"
"        float bornRadius = bornRadii[index];\n"
"        float r = offsetRadius+DIELECTRIC_OFFSET+PROBE_RADIUS;\n"
"        float ratio6 = pow((offsetRadius+DIELECTRIC_OFFSET)/bornRadius, 6.0f);\n"
"        float saTerm = SURFACE_AREA_FACTOR*r*r*ratio6;\n"
"        force += saTerm/bornRadius;\n"
"        energy += saTerm;\n"
"        force *= bornRadius*bornRadius*obcChain[index];\n"
"        bornForce[index] = force;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy/-6.0f;\n"
"}";
const string OpenCLKernelSources::findInteractingBlocks = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"#define TILE_SIZE 32\n"
"#define GROUP_SIZE 64\n"
"#define BUFFER_GROUPS 4\n"
"#define BUFFER_SIZE BUFFER_GROUPS*GROUP_SIZE\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"__kernel void findBlockBounds(int numAtoms, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global const float4* restrict posq, __global float4* restrict blockCenter, __global float4* restrict blockBoundingBox, __global unsigned int* restrict interactionCount) {\n"
"    int index = get_global_id(0);\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        float4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        pos.x -= floor(pos.x*invPeriodicBoxSize.x)*periodicBoxSize.x;\n"
"        pos.y -= floor(pos.y*invPeriodicBoxSize.y)*periodicBoxSize.y;\n"
"        pos.z -= floor(pos.z*invPeriodicBoxSize.z)*periodicBoxSize.z;\n"
"        float4 firstPoint = pos;\n"
"#endif\n"
"        float4 minPos = pos;\n"
"        float4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            pos.x -= floor((pos.x-firstPoint.x)*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"            pos.y -= floor((pos.y-firstPoint.y)*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"            pos.z -= floor((pos.z-firstPoint.z)*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"            minPos = min(minPos, pos);\n"
"            maxPos = max(maxPos, pos);\n"
"        }\n"
"        blockBoundingBox[index] = 0.5f*(maxPos-minPos);\n"
"        blockCenter[index] = 0.5f*(maxPos+minPos);\n"
"        index += get_global_size(0);\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        interactionCount[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * This is called by findBlocksWithInteractions().  It compacts the list of blocks and writes them\n"
" * to global memory.\n"
" */\n"
"void storeInteractionData(__local ushort2* buffer, __local int* valid, __local short* sum, __local ushort2* temp, __local int* baseIndex,\n"
"            __global unsigned int* interactionCount, __global ushort2* interactingTiles, float cutoffSquared, float4 periodicBoxSize,\n"
"            float4 invPeriodicBoxSize, __global const float4* posq, __global const float4* blockCenter, __global const float4* blockBoundingBox, unsigned int maxTiles) {\n"
"    // The buffer is full, so we need to compact it and write out results.  Start by doing a parallel prefix sum.\n"
"\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += GROUP_SIZE)\n"
"        temp[i].x = (valid[i] ? 1 : 0);\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    int whichBuffer = 0;\n"
"    for (int offset = 1; offset < BUFFER_SIZE; offset *= 2) {\n"
"        if (whichBuffer == 0)\n"
"            for (int i = get_local_id(0); i < BUFFER_SIZE; i += GROUP_SIZE)\n"
"                temp[i].y = (i < offset ? temp[i].x : temp[i].x+temp[i-offset].x);\n"
"        else\n"
"            for (int i = get_local_id(0); i < BUFFER_SIZE; i += GROUP_SIZE)\n"
"                temp[i].x = (i < offset ? temp[i].y : temp[i].y+temp[i-offset].y);\n"
"        whichBuffer = 1-whichBuffer;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    if (whichBuffer == 0)\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += GROUP_SIZE)\n"
"            sum[i] = temp[i].x;\n"
"    else\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += GROUP_SIZE)\n"
"            sum[i] = temp[i].y;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    int numValid = sum[BUFFER_SIZE-1];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Compact the buffer.\n"
"\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += GROUP_SIZE)\n"
"        if (valid[i]) {\n"
"            temp[sum[i]-1] = buffer[i];\n"
"            sum[i] = valid[i];\n"
"            valid[i] = false;\n"
"            buffer[i] = (ushort2) 1;\n"
"        }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"#ifndef WARPS_ARE_ATOMIC\n"
"    // Filter the list of tiles by comparing the distance from each atom to the other bounding box.\n"
"    // We only do this if we aren't already optimizing the computation using flags.\n"
"\n"
"    int index = get_local_id(0)&(TILE_SIZE-1);\n"
"    int group = get_local_id(0)/TILE_SIZE;\n"
"    float4 center, boxSize, pos;\n"
"    for (int tile = 0; tile < numValid; tile++) {\n"
"        int x = temp[tile].x;\n"
"        int y = temp[tile].y;\n"
"        if (x == y)\n"
"            continue;\n"
"\n"
"        // Load an atom position and the bounding box the other block.\n"
"\n"
"#ifdef MAC_AMD_WORKAROUND\n"
"        int box = (group == 0 ? x : y);\n"
"        int atom = (group == 0 ? y : x)*TILE_SIZE+index;\n"
"        __global float* bc = (__global float*) blockCenter;\n"
"        __global float* bb = (__global float*) blockBoundingBox;\n"
"        __global float* ps = (__global float*) posq;\n"
"        center = (float4) (bc[4*box], bc[4*box+1], bc[4*box+2], 0.0f);\n"
"        boxSize = (float4) (bb[4*box], bb[4*box+1], bb[4*box+2], 0.0f);\n"
"        pos = (float4) (ps[4*atom], ps[4*atom+1], ps[4*atom+2], 0.0f);\n"
"#else\n"
"        center = blockCenter[(group == 0 ? x : y)];\n"
"        boxSize = blockBoundingBox[(group == 0 ? x : y)];\n"
"        pos = posq[(group == 0 ? y : x)*TILE_SIZE+index];\n"
"#endif\n"
"\n"
"        // Find the distance of the atom from the bounding box.\n"
"\n"
"        float4 delta = pos-center;\n"
"#ifdef USE_PERIODIC\n"
"        delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"        delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"        delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"        delta = max((float4) 0.0f, fabs(delta)-boxSize);\n"
"        __local ushort* flag = (__local ushort*) &buffer[tile];\n"
"        if (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < cutoffSquared)\n"
"            flag[group] = false;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (flag[0] || flag[1]) {\n"
"            // This tile contains no interactions.\n"
"\n"
"            numValid--;\n"
"            if (get_local_id(0) == 0)\n"
"                temp[tile] = temp[numValid];\n"
"            tile--;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"#endif\n"
"\n"
"    // Store it to global memory.\n"
"\n"
"    if (get_local_id(0) == 0)\n"
"        *baseIndex = atom_add(interactionCount, numValid);\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (*baseIndex+numValid <= maxTiles)\n"
"        for (int i = get_local_id(0); i < numValid; i += GROUP_SIZE)\n"
"            interactingTiles[*baseIndex+i] = temp[i];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"/**\n"
" * Compare the bounding boxes for each pair of blocks.  If they are sufficiently far apart,\n"
" * mark them as non-interacting.\n"
" */\n"
"__kernel void findBlocksWithInteractions(float cutoffSquared, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global const float4* restrict blockCenter,\n"
"        __global const float4* restrict blockBoundingBox, __global unsigned int* restrict interactionCount, __global ushort2* restrict interactingTiles,\n"
"        __global unsigned int* restrict interactionFlags, __global const float4* restrict posq, unsigned int maxTiles, unsigned int startTileIndex,\n"
"        unsigned int endTileIndex) {\n"
"    __local ushort2 buffer[BUFFER_SIZE];\n"
"    __local int valid[BUFFER_SIZE];\n"
"    __local short sum[BUFFER_SIZE];\n"
"    __local ushort2 temp[BUFFER_SIZE];\n"
"    __local int bufferFull;\n"
"    __local int globalIndex;\n"
"#ifdef AMD_ATOMIC_WORK_AROUND\n"
"    // Do a byte write to force all memory accesses to interactionCount to use the complete path.\n"
"    // This avoids the atomic access from causing all word accesses to other buffers from using the slow complete path.\n"
"    // The IF actually causes the write to never be executed, its presence is all that is needed.\n"
"    // AMD APP SDK 2.4 has this problem.\n"
"    if (get_global_id(0) == get_local_id(0)+1)\n"
"        ((__global char*)interactionCount)[sizeof(unsigned int)+1] = 0;\n"
"#endif\n"
"    int valuesInBuffer = 0;\n"
"    if (get_local_id(0) == 0)\n"
"        bufferFull = false;\n"
"    for (int i = 0; i < BUFFER_GROUPS; ++i)\n"
"        valid[i*GROUP_SIZE+get_local_id(0)] = false;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int baseIndex = startTileIndex+get_group_id(0)*get_local_size(0); baseIndex < endTileIndex; baseIndex += get_global_size(0)) {\n"
"        // Identify the pair of blocks to compare.\n"
"\n"
"        int index = baseIndex+get_local_id(0);\n"
"        if (index < endTileIndex) {\n"
"            unsigned int y = (unsigned int) floor(NUM_BLOCKS+0.5f-sqrt((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*index));\n"
"            unsigned int x = (index-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"                y += (x < y ? -1 : 1);\n"
"                x = (index-y*NUM_BLOCKS+y*(y+1)/2);\n"
"            }\n"
"\n"
"            // Find the distance between the bounding boxes of the two cells.\n"
"\n"
"#ifdef MAC_AMD_WORKAROUND\n"
"            __global float* bc = (__global float*) blockCenter;\n"
"            __global float* bb = (__global float*) blockBoundingBox;\n"
"            float4 bcx = (float4) (bc[4*x], bc[4*x+1], bc[4*x+2], 0.0f);\n"
"            float4 bcy = (float4) (bc[4*y], bc[4*y+1], bc[4*y+2], 0.0f);\n"
"            float4 delta = bcx-bcy;\n"
"            float4 boxSizea = (float4) (bb[4*x], bb[4*x+1], bb[4*x+2], 0.0f);\n"
"            float4 boxSizeb = (float4) (bb[4*y], bb[4*y+1], bb[4*y+2], 0.0f);\n"
"#else\n"
"            float4 delta = blockCenter[x]-blockCenter[y];\n"
"            float4 boxSizea = blockBoundingBox[x];\n"
"            float4 boxSizeb = blockBoundingBox[y];\n"
"#endif\n"
"#ifdef USE_PERIODIC\n"
"            delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"            delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"            delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"            delta.x = max(0.0f, fabs(delta.x)-boxSizea.x-boxSizeb.x);\n"
"            delta.y = max(0.0f, fabs(delta.y)-boxSizea.y-boxSizeb.y);\n"
"            delta.z = max(0.0f, fabs(delta.z)-boxSizea.z-boxSizeb.z);\n"
"            if (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < cutoffSquared) {\n"
"                // Add this tile to the buffer.\n"
"\n"
"                int bufferIndex = valuesInBuffer*GROUP_SIZE+get_local_id(0);\n"
"                valid[bufferIndex] = true;\n"
"                buffer[bufferIndex] = (ushort2) (x, y);\n"
"                valuesInBuffer++;\n"
"                if (!bufferFull && valuesInBuffer == BUFFER_GROUPS)\n"
"                    bufferFull = true;\n"
"            }\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (bufferFull) {\n"
"            storeInteractionData(buffer, valid, sum, temp, &globalIndex, interactionCount, interactingTiles, cutoffSquared, periodicBoxSize, invPeriodicBoxSize, posq, blockCenter, blockBoundingBox, maxTiles);\n"
"            valuesInBuffer = 0;\n"
"            if (get_local_id(0) == 0)\n"
"                bufferFull = false;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"    }\n"
"    storeInteractionData(buffer, valid, sum, temp, &globalIndex, interactionCount, interactingTiles, cutoffSquared, periodicBoxSize, invPeriodicBoxSize, posq, blockCenter, blockBoundingBox, maxTiles);\n"
"}\n"
"\n"
"/**\n"
" * Compare each atom in one block to the bounding box of another block, and set\n"
" * flags for which ones are interacting.\n"
" */\n"
"__kernel void findInteractionsWithinBlocks(float cutoffSquared, float4 periodicBoxSize, float4 invPeriodicBoxSize, __global const float4* restrict posq, __global const ushort2* restrict tiles, __global const float4* restrict blockCenter,\n"
"            __global const float4* restrict blockBoundingBox, __global unsigned int* restrict interactionFlags, __global const unsigned int* restrict interactionCount, __local volatile unsigned int* restrict flags, unsigned int maxTiles) {\n"
"    unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    unsigned int pos = warp*numTiles/totalWarps;\n"
"    unsigned int end = (warp+1)*numTiles/totalWarps;\n"
"    unsigned int index = get_local_id(0) & (TILE_SIZE - 1);\n"
"\n"
"    if (numTiles > maxTiles)\n"
"        return;\n"
"    unsigned int lasty = 0xFFFFFFFF;\n"
"    float4 apos;\n"
"    while (pos < end) {\n"
"        // Extract the coordinates of this tile\n"
"        ushort2 tileIndices = tiles[pos];\n"
"        unsigned int x = tileIndices.x;\n"
"        unsigned int y = tileIndices.y;\n"
"        if (x == y) {\n"
"            if (index == 0)\n"
"                interactionFlags[pos] = 0xFFFFFFFF;\n"
"        }\n"
"        else {\n"
"            // Load the bounding box for x and the atom positions for y.\n"
"\n"
"            float4 center = blockCenter[x];\n"
"            float4 boxSize = blockBoundingBox[x];\n"
"            if (y != lasty)\n"
"                apos = posq[y*TILE_SIZE+index];\n"
"\n"
"            // Find the distance of the atom from the bounding box.\n"
"\n"
"            float4 delta = apos-center;\n"
"#ifdef USE_PERIODIC\n"
"                delta.x -= floor(delta.x*invPeriodicBoxSize.x+0.5f)*periodicBoxSize.x;\n"
"                delta.y -= floor(delta.y*invPeriodicBoxSize.y+0.5f)*periodicBoxSize.y;\n"
"                delta.z -= floor(delta.z*invPeriodicBoxSize.z+0.5f)*periodicBoxSize.z;\n"
"#endif\n"
"            delta = max((float4) 0.0f, fabs(delta)-boxSize);\n"
"            int thread = get_local_id(0);\n"
"            flags[thread] = (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z > cutoffSquared ? 0 : 1 << index);\n"
"\n"
"            // Sum the flags.\n"
"\n"
"#ifdef WARPS_ARE_ATOMIC\n"
"            if (index % 4 == 0)\n"
"                flags[thread] += flags[thread+1]+flags[thread+2]+flags[thread+3];\n"
"#else\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (index % 4 == 0)\n"
"                flags[thread] += flags[thread+1]+flags[thread+2]+flags[thread+3];\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"            if (index == 0) {\n"
"                unsigned int allFlags = flags[thread]+flags[thread+4]+flags[thread+8]+flags[thread+12]+flags[thread+16]+flags[thread+20]+flags[thread+24]+flags[thread+28];\n"
"\n"
"                // Count how many flags are set, and based on that decide whether to compute all interactions\n"
"                // or only a fraction of them.\n"
"\n"
"                unsigned int bits = (allFlags&0x55555555) + ((allFlags>>1)&0x55555555);\n"
"                bits = (bits&0x33333333) + ((bits>>2)&0x33333333);\n"
"                bits = (bits&0x0F0F0F0F) + ((bits>>4)&0x0F0F0F0F);\n"
"                bits = (bits&0x00FF00FF) + ((bits>>8)&0x00FF00FF);\n"
"                bits = (bits&0x0000FFFF) + ((bits>>16)&0x0000FFFF);\n"
"                interactionFlags[pos] = (bits > 12 ? 0xFFFFFFFF : allFlags);\n"
"            }\n"
"            lasty = y;\n"
"        }\n"
"        pos++;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::customTorsionForce = "float4 v0 = (float4) (pos1.xyz-pos2.xyz, 0.0f);\n"
"float4 v1 = (float4) (pos3.xyz-pos2.xyz, 0.0f);\n"
"float4 v2 = (float4) (pos3.xyz-pos4.xyz, 0.0f);\n"
"float4 cp0 = cross(v0, v1);\n"
"float4 cp1 = cross(v1, v2);\n"
"float cosangle = dot(normalize(cp0), normalize(cp1));\n"
"float theta;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    float4 cross_prod = cross(cp0, cp1);\n"
"    float scale = dot(cp0, cp0)*dot(cp1, cp1);\n"
"    theta = asin(sqrt(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0.0f)\n"
"        theta = M_PI-theta;\n"
"}\n"
"else\n"
"   theta = acos(cosangle);\n"
"theta = (dot(v0, cp1) >= 0 ? theta : -theta);\n"
"COMPUTE_FORCE\n"
"float normCross1 = dot(cp0, cp0);\n"
"float normSqrBC = dot(v1, v1);\n"
"float normBC = sqrt(normSqrBC);\n"
"float normCross2 = dot(cp1, cp1);\n"
"float dp = 1.0f/normSqrBC;\n"
"float4 ff = (float4) ((-dEdAngle*normBC)/normCross1, dot(v0, v1)*dp, dot(v2, v1)*dp, (dEdAngle*normBC)/normCross2);\n"
"float4 force1 = ff.x*cp0;\n"
"float4 force4 = ff.w*cp1;\n"
"float4 s = ff.y*force1 - ff.z*force4;\n"
"float4 force2 = s-force1;\n"
"float4 force3 = -s-force4;\n"
"";
const string OpenCLKernelSources::binproperties = "#ifdef SUPPORTS_DOUBLE_PRECISION\n"
"    #pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#endif\n"
"/**\n"
" * binProperties\n"
" * this file consists of kernel code for binproperties kernel \n"
" */\n"
"\n"
"__kernel void binproperties(int numAtoms,\n"
"                            int nBins,\n"
"                            __global const float4* restrict posq,\n"
"                            __global const float4* restrict velm,\n"
"                            __global const float4* startPoint,\n"
"                            __global const float4* unitVector,\n"
"                            __global int* mols,\n"
"                            __global float4* measure\n"
"                            )\n"
"{\n"
"    unsigned int idx = get_global_id(0);\n"
"    float4 sp = startPoint[0];\n"
"    float4 uv = unitVector[0];\n"
"    float rD = 0.0;\n"
"    if(idx<numAtoms)\n"
"    {\n"
"        float4 velocity = velm[idx];\n"
"        float4 rSI = posq[idx] - sp;\n"
"        //calculate dot product rSI * unitVector\n"
"        rD = ((rSI.x*uv.x)+(rSI.y*uv.y)+(rSI.z*uv.z));\n"
"        int bn = (int) rD/uv.w;//try will ceil if the  sums aren't appropriate\n"
"        unsigned int s = bn == nBins;\n"
"        bn -= s;\n"
"        rD = ((velocity.x*velocity.x)+(velocity.y*velocity.y)+(velocity.z*velocity.z));//reuse of rD variable\n"
"        mols[idx*nBins+bn] += 1;\n"
"        measure[idx*nBins+bn] += (float4) (velocity.x * (1.0f/velocity.w),\n"
"                                           velocity.y * (1.0f/velocity.w),\n"
"                                           velocity.z * (1.0f/velocity.w),\n"
"                                           0.5f * (1.0f/velocity.w) * rD);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::coulombLennardJones = "#if USE_EWALD\n"
"bool needCorrection = isExcluded && atom1 != atom2 && atom1 < NUM_ATOMS && atom2 < NUM_ATOMS;\n"
"if (!isExcluded || needCorrection) {\n"
"    float tempForce = 0.0f;\n"
"    if (r2 < CUTOFF_SQUARED || needCorrection) {\n"
"        const float alphaR = EWALD_ALPHA*r;\n"
"        const float expAlphaRSqr = EXP(-alphaR*alphaR);\n"
"        const float prefactor = 138.935456f*posq1.w*posq2.w*invR;\n"
"\n"
"        // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"        // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"        // error of 3e-7.\n"
"\n"
"        float t = 1.0f+(0.0705230784f+(0.0422820123f+(0.0092705272f+(0.0001520143f+(0.0002765672f+0.0000430638f*alphaR)*alphaR)*alphaR)*alphaR)*alphaR)*alphaR;\n"
"        t *= t;\n"
"        t *= t;\n"
"        t *= t;\n"
"        const float erfcAlphaR = RECIP(t*t);\n"
"        if (needCorrection) {\n"
"            // Subtract off the part of this interaction that was included in the reciprocal space contribution.\n"
"\n"
"            tempForce = -prefactor*((1.0f-erfcAlphaR)-alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"            tempEnergy += -prefactor*(1.0f-erfcAlphaR);\n"
"        }\n"
"        else {\n"
"#if HAS_LENNARD_JONES\n"
"            float sig = sigmaEpsilon1.x + sigmaEpsilon2.x;\n"
"            float sig2 = invR*sig;\n"
"            sig2 *= sig2;\n"
"            float sig6 = sig2*sig2*sig2;\n"
"            float epssig6 = sig6*(sigmaEpsilon1.y*sigmaEpsilon2.y);\n"
"            tempForce = epssig6*(12.0f*sig6 - 6.0f) + prefactor*(erfcAlphaR+alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"            tempEnergy += epssig6*(sig6 - 1.0f) + prefactor*erfcAlphaR;\n"
"#else\n"
"            tempForce = prefactor*(erfcAlphaR+alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"            tempEnergy += prefactor*erfcAlphaR;\n"
"#endif\n"
"        }\n"
"    }\n"
"    dEdR += tempForce*invR*invR;\n"
"}\n"
"#else\n"
"{\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"    unsigned int includeInteraction = (!isExcluded);\n"
"#endif\n"
"    float tempForce = 0.0f;\n"
"  #if HAS_LENNARD_JONES\n"
"    float sig = sigmaEpsilon1.x + sigmaEpsilon2.x;\n"
"    float sig2 = invR*sig;\n"
"    sig2 *= sig2;\n"
"    float sig6 = sig2*sig2*sig2;\n"
"    float epssig6 = sig6*(sigmaEpsilon1.y*sigmaEpsilon2.y);\n"
"    tempForce = epssig6*(12.0f*sig6 - 6.0f);\n"
"    tempEnergy += select(0.0f, epssig6*(sig6 - 1.0f), includeInteraction);\n"
"  #endif\n"
"#if HAS_COULOMB\n"
"  #ifdef USE_CUTOFF\n"
"    const float prefactor = 138.935456f*posq1.w*posq2.w;\n"
"    tempForce += prefactor*(invR - 2.0f*REACTION_FIELD_K*r2);\n"
"    tempEnergy += select(0.0f, prefactor*(invR + REACTION_FIELD_K*r2 - REACTION_FIELD_C), includeInteraction);\n"
"  #else\n"
"    const float prefactor = 138.935456f*posq1.w*posq2.w*invR;\n"
"    tempForce += prefactor;\n"
"    tempEnergy += select(0.0f, prefactor, includeInteraction);\n"
"  #endif\n"
"#endif\n"
"    dEdR += select(0.0f, tempForce*invR*invR, includeInteraction);\n"
"}\n"
"#endif";
const string OpenCLKernelSources::settle = "/**\n"
" * Enforce constraints on SETTLE clusters\n"
" */\n"
"\n"
"__kernel void applySettle(int numClusters, float tol, __global const float4* restrict oldPos, __global float4* restrict posDelta, __global const float4* restrict velm, __global const int4* restrict clusterAtoms, __global const float2* restrict clusterParams) {\n"
"    int index = get_global_id(0);\n"
"    while (index < numClusters) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        float2 params = clusterParams[index];\n"
"        float4 apos0 = oldPos[atoms.x];\n"
"        float4 xp0 = posDelta[atoms.x];\n"
"        float4 apos1 = oldPos[atoms.y];\n"
"        float4 xp1 = posDelta[atoms.y];\n"
"        float4 apos2 = oldPos[atoms.z];\n"
"        float4 xp2 = posDelta[atoms.z];\n"
"        float m0 = RECIP(velm[atoms.x].w);\n"
"        float m1 = RECIP(velm[atoms.y].w);\n"
"        float m2 = RECIP(velm[atoms.z].w);\n"
"\n"
"        // Apply the SETTLE algorithm.\n"
"\n"
"        float xb0 = apos1.x-apos0.x;\n"
"        float yb0 = apos1.y-apos0.y;\n"
"        float zb0 = apos1.z-apos0.z;\n"
"        float xc0 = apos2.x-apos0.x;\n"
"        float yc0 = apos2.y-apos0.y;\n"
"        float zc0 = apos2.z-apos0.z;\n"
"\n"
"        float invTotalMass = 1.0f/(m0+m1+m2);\n"
"        float xcom = (xp0.x*m0 + (xb0+xp1.x)*m1 + (xc0+xp2.x)*m2) * invTotalMass;\n"
"        float ycom = (xp0.y*m0 + (yb0+xp1.y)*m1 + (yc0+xp2.y)*m2) * invTotalMass;\n"
"        float zcom = (xp0.z*m0 + (zb0+xp1.z)*m1 + (zc0+xp2.z)*m2) * invTotalMass;\n"
"\n"
"        float xa1 = xp0.x - xcom;\n"
"        float ya1 = xp0.y - ycom;\n"
"        float za1 = xp0.z - zcom;\n"
"        float xb1 = xb0 + xp1.x - xcom;\n"
"        float yb1 = yb0 + xp1.y - ycom;\n"
"        float zb1 = zb0 + xp1.z - zcom;\n"
"        float xc1 = xc0 + xp2.x - xcom;\n"
"        float yc1 = yc0 + xp2.y - ycom;\n"
"        float zc1 = zc0 + xp2.z - zcom;\n"
"\n"
"        float xaksZd = yb0*zc0 - zb0*yc0;\n"
"        float yaksZd = zb0*xc0 - xb0*zc0;\n"
"        float zaksZd = xb0*yc0 - yb0*xc0;\n"
"        float xaksXd = ya1*zaksZd - za1*yaksZd;\n"
"        float yaksXd = za1*xaksZd - xa1*zaksZd;\n"
"        float zaksXd = xa1*yaksZd - ya1*xaksZd;\n"
"        float xaksYd = yaksZd*zaksXd - zaksZd*yaksXd;\n"
"        float yaksYd = zaksZd*xaksXd - xaksZd*zaksXd;\n"
"        float zaksYd = xaksZd*yaksXd - yaksZd*xaksXd;\n"
"\n"
"        float axlng = sqrt(xaksXd*xaksXd + yaksXd*yaksXd + zaksXd*zaksXd);\n"
"        float aylng = sqrt(xaksYd*xaksYd + yaksYd*yaksYd + zaksYd*zaksYd);\n"
"        float azlng = sqrt(xaksZd*xaksZd + yaksZd*yaksZd + zaksZd*zaksZd);\n"
"        float trns11 = xaksXd / axlng;\n"
"        float trns21 = yaksXd / axlng;\n"
"        float trns31 = zaksXd / axlng;\n"
"        float trns12 = xaksYd / aylng;\n"
"        float trns22 = yaksYd / aylng;\n"
"        float trns32 = zaksYd / aylng;\n"
"        float trns13 = xaksZd / azlng;\n"
"        float trns23 = yaksZd / azlng;\n"
"        float trns33 = zaksZd / azlng;\n"
"\n"
"        float xb0d = trns11*xb0 + trns21*yb0 + trns31*zb0;\n"
"        float yb0d = trns12*xb0 + trns22*yb0 + trns32*zb0;\n"
"        float xc0d = trns11*xc0 + trns21*yc0 + trns31*zc0;\n"
"        float yc0d = trns12*xc0 + trns22*yc0 + trns32*zc0;\n"
"        float za1d = trns13*xa1 + trns23*ya1 + trns33*za1;\n"
"        float xb1d = trns11*xb1 + trns21*yb1 + trns31*zb1;\n"
"        float yb1d = trns12*xb1 + trns22*yb1 + trns32*zb1;\n"
"        float zb1d = trns13*xb1 + trns23*yb1 + trns33*zb1;\n"
"        float xc1d = trns11*xc1 + trns21*yc1 + trns31*zc1;\n"
"        float yc1d = trns12*xc1 + trns22*yc1 + trns32*zc1;\n"
"        float zc1d = trns13*xc1 + trns23*yc1 + trns33*zc1;\n"
"\n"
"        //                                        --- Step2  A2' ---\n"
"\n"
"        float rc = 0.5*params.y;\n"
"        float rb = sqrt(params.x*params.x-rc*rc);\n"
"        float ra = rb*(m1+m2)*invTotalMass;\n"
"        rb -= ra;\n"
"        float sinphi = za1d / ra;\n"
"        float cosphi = sqrt(1.0f - sinphi*sinphi);\n"
"        float sinpsi = (zb1d - zc1d) / (2*rc*cosphi);\n"
"        float cospsi = sqrt(1.0f - sinpsi*sinpsi);\n"
"\n"
"        float ya2d =   ra*cosphi;\n"
"        float xb2d = - rc*cospsi;\n"
"        float yb2d = - rb*cosphi - rc*sinpsi*sinphi;\n"
"        float yc2d = - rb*cosphi + rc*sinpsi*sinphi;\n"
"        float xb2d2 = xb2d*xb2d;\n"
"        float hh2 = 4.0f*xb2d2 + (yb2d-yc2d)*(yb2d-yc2d) + (zb1d-zc1d)*(zb1d-zc1d);\n"
"        float deltx = 2.0f*xb2d + sqrt(4.0f*xb2d2 - hh2 + params.y*params.y);\n"
"        xb2d -= deltx*0.5;\n"
"\n"
"        //                                        --- Step3  al,be,ga ---\n"
"\n"
"        float alpha = (xb2d*(xb0d-xc0d) + yb0d*yb2d + yc0d*yc2d);\n"
"        float beta = (xb2d*(yc0d-yb0d) + xb0d*yb2d + xc0d*yc2d);\n"
"        float gamma = xb0d*yb1d - xb1d*yb0d + xc0d*yc1d - xc1d*yc0d;\n"
"\n"
"        float al2be2 = alpha*alpha + beta*beta;\n"
"        float sintheta = (alpha*gamma - beta*sqrt(al2be2 - gamma*gamma)) / al2be2;\n"
"\n"
"        //                                        --- Step4  A3' ---\n"
"\n"
"        float costheta = sqrt(1.0f - sintheta*sintheta);\n"
"        float xa3d = - ya2d*sintheta;\n"
"        float ya3d =   ya2d*costheta;\n"
"        float za3d = za1d;\n"
"        float xb3d =   xb2d*costheta - yb2d*sintheta;\n"
"        float yb3d =   xb2d*sintheta + yb2d*costheta;\n"
"        float zb3d = zb1d;\n"
"        float xc3d = - xb2d*costheta - yc2d*sintheta;\n"
"        float yc3d = - xb2d*sintheta + yc2d*costheta;\n"
"        float zc3d = zc1d;\n"
"\n"
"        //                                        --- Step5  A3 ---\n"
"\n"
"        float xa3 = trns11*xa3d + trns12*ya3d + trns13*za3d;\n"
"        float ya3 = trns21*xa3d + trns22*ya3d + trns23*za3d;\n"
"        float za3 = trns31*xa3d + trns32*ya3d + trns33*za3d;\n"
"        float xb3 = trns11*xb3d + trns12*yb3d + trns13*zb3d;\n"
"        float yb3 = trns21*xb3d + trns22*yb3d + trns23*zb3d;\n"
"        float zb3 = trns31*xb3d + trns32*yb3d + trns33*zb3d;\n"
"        float xc3 = trns11*xc3d + trns12*yc3d + trns13*zc3d;\n"
"        float yc3 = trns21*xc3d + trns22*yc3d + trns23*zc3d;\n"
"        float zc3 = trns31*xc3d + trns32*yc3d + trns33*zc3d;\n"
"\n"
"        xp0.x = xcom + xa3;\n"
"        xp0.y = ycom + ya3;\n"
"        xp0.z = zcom + za3;\n"
"        xp1.x = xcom + xb3 - xb0;\n"
"        xp1.y = ycom + yb3 - yb0;\n"
"        xp1.z = zcom + zb3 - zb0;\n"
"        xp2.x = xcom + xc3 - xc0;\n"
"        xp2.y = ycom + yc3 - yc0;\n"
"        xp2.z = zcom + zc3 - zc0;\n"
"\n"
"        // Record the new positions.\n"
"\n"
"        posDelta[atoms.x] = xp0;\n"
"        posDelta[atoms.y] = xp1;\n"
"        posDelta[atoms.z] = xp2;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Enforce velocity constraints on SETTLE clusters\n"
" */\n"
"\n"
"__kernel void constrainVelocities(int numClusters, float tol, __global const float4* restrict oldPos, __global float4* restrict posDelta, __global float4* restrict velm, __global const int4* restrict clusterAtoms, __global const float2* restrict clusterParams) {\n"
"    for (int index = get_global_id(0); index < numClusters; index += get_global_size(0)) {\n"
"        // Load the data for this cluster.\n"
"\n"
"        int4 atoms = clusterAtoms[index];\n"
"        float4 apos0 = oldPos[atoms.x];\n"
"        float4 apos1 = oldPos[atoms.y];\n"
"        float4 apos2 = oldPos[atoms.z];\n"
"        float4 v0 = velm[atoms.x];\n"
"        float4 v1 = velm[atoms.y];\n"
"        float4 v2 = velm[atoms.z];\n"
"        \n"
"        // Compute intermediate quantities: the atom masses, the bond directions, the relative velocities,\n"
"        // and the angle cosines and sines.\n"
"        \n"
"        float mA = RECIP(v0.w);\n"
"        float mB = RECIP(v1.w);\n"
"        float mC = RECIP(v2.w);\n"
"        float4 eAB = apos1-apos0;\n"
"        float4 eBC = apos2-apos1;\n"
"        float4 eCA = apos0-apos2;\n"
"        eAB.xyz /= SQRT(eAB.x*eAB.x + eAB.y*eAB.y + eAB.z*eAB.z);\n"
"        eBC.xyz /= SQRT(eBC.x*eBC.x + eBC.y*eBC.y + eBC.z*eBC.z);\n"
"        eCA.xyz /= SQRT(eCA.x*eCA.x + eCA.y*eCA.y + eCA.z*eCA.z);\n"
"        float vAB = (v1.x-v0.x)*eAB.x + (v1.y-v0.y)*eAB.y + (v1.z-v0.z)*eAB.z;\n"
"        float vBC = (v2.x-v1.x)*eBC.x + (v2.y-v1.y)*eBC.y + (v2.z-v1.z)*eBC.z;\n"
"        float vCA = (v0.x-v2.x)*eCA.x + (v0.y-v2.y)*eCA.y + (v0.z-v2.z)*eCA.z;\n"
"        float cA = -(eAB.x*eCA.x + eAB.y*eCA.y + eAB.z*eCA.z);\n"
"        float cB = -(eAB.x*eBC.x + eAB.y*eBC.y + eAB.z*eBC.z);\n"
"        float cC = -(eBC.x*eCA.x + eBC.y*eCA.y + eBC.z*eCA.z);\n"
"        float s2A = 1-cA*cA;\n"
"        float s2B = 1-cB*cB;\n"
"        float s2C = 1-cC*cC;\n"
"        \n"
"        // Solve the equations.  These are different from those in the SETTLE paper (JCC 13(8), pp. 952-962, 1992), because\n"
"        // in going from equations B1 to B2, they make the assumption that mB=mC (but don't bother to mention they're\n"
"        // making that assumption).  We allow all three atoms to have different masses.\n"
"        \n"
"        float mABCinv = RECIP(mA*mB*mC);\n"
"        float denom = (((s2A*mB+s2B*mA)*mC+(s2A*mB*mB+2*(cA*cB*cC+1)*mA*mB+s2B*mA*mA))*mC+s2C*mA*mB*(mA+mB))*mABCinv;\n"
"        float tab = ((cB*cC*mA-cA*mB-cA*mC)*vCA + (cA*cC*mB-cB*mC-cB*mA)*vBC + (s2C*mA*mA*mB*mB*mABCinv+(mA+mB+mC))*vAB)/denom;\n"
"        float tbc = ((cA*cB*mC-cC*mB-cC*mA)*vCA + (s2A*mB*mB*mC*mC*mABCinv+(mA+mB+mC))*vBC + (cA*cC*mB-cB*mA-cB*mC)*vAB)/denom;\n"
"        float tca = ((s2B*mA*mA*mC*mC*mABCinv+(mA+mB+mC))*vCA + (cA*cB*mC-cC*mB-cC*mA)*vBC + (cB*cC*mA-cA*mB-cA*mC)*vAB)/denom;\n"
"        v0.xyz += (tab*eAB.xyz - tca*eCA.xyz)*v0.w;\n"
"        v1.xyz += (tbc*eBC.xyz - tab*eAB.xyz)*v1.w;\n"
"        v2.xyz += (tca*eCA.xyz - tbc*eBC.xyz)*v2.w;\n"
"        velm[atoms.x] = v0;\n"
"        velm[atoms.y] = v1;\n"
"        velm[atoms.z] = v2;\n"
"    }\n"
"}";
